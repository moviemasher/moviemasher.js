"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("express"),t=require("fluent-ffmpeg"),i=require("@moviemasher/moviemasher.js"),r=require("path"),s=require("fs"),n=require("child_process"),o=require("cors"),a=require("express-basic-auth"),c=require("sqlite"),d=require("sqlite3"),u=require("@bitjourney/uuid-v4"),h=require("multer"),p=require("events"),l=require("http"),m=require("https"),f=require("md5"),g=require("stream"),y=require("net");function S(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var v=S(e),b=S(t),P=S(r),x=S(s),D=S(o),w=S(a),E=S(d),C=S(h),T=S(p),O=S(l),F=S(m),$=S(f),I=S(y);const R=e=>Object.entries(e).map((([e,t])=>{const i=`-${e}`,r=String(t);return r.length?`${i} ${r}`:i})),j=()=>{const e={logger:{warn:console.warn,error:console.error,debug:console.debug,info:console.info}};return b.default(e)},k=e=>{const t=j(),{inputs:r,output:s,commandFilters:n,avType:o}=e;if(o===i.AVType.Video?t.noAudio():o===i.AVType.Audio&&t.noVideo(),r?.forEach((({source:e,options:i})=>{t.addInput(e),i&&t.addInputOptions(R(i))})),n?.length){t.complexFilter((e=>e.map((e=>{const{options:t,ffmpegFilter:r,...s}=e;return{...s,options:Object.entries(t).map((([e,t])=>i.isNumber(t)?`${e}=${t}`:t.length?`${e}=${t.replaceAll(",","\\,").replaceAll(":","\\\\:")}`:e.replaceAll(",","\\,"))).join(":"),filter:r}})))(n));n[n.length-1].outputs.forEach((e=>{t.map(`[${e}]`)}))}o!==i.AVType.Video&&(i.isPopulatedString(s.audioCodec)&&t.audioCodec(s.audioCodec),i.isValue(s.audioBitrate)&&t.audioBitrate(s.audioBitrate),i.isAboveZero(s.audioChannels)&&t.audioChannels(s.audioChannels),i.isAboveZero(s.audioRate)&&t.audioFrequency(s.audioRate)),o!==i.AVType.Audio&&(i.isPopulatedString(s.videoCodec)&&t.videoCodec(s.videoCodec),i.isAboveZero(s.videoRate)&&t.fpsOutput(s.videoRate));const a=s.options||{},c=i.isPopulatedObject(a)?a:{};return c.hide_banner="",c.shortest="",t.addOptions(R(c)),t},A=[/Input frame sizes do not match \([0-9]*x[0-9]* vs [0-9]*x[0-9]*\)/,/Option '[0-9a-z_-]*' not found/,"Error:","Cannot find a matching stream","Unable to parse option value","Invalid too big or non positive size"],L=e=>{if(!e.includes(";"))return e;return e.split(";").map((e=>{const[t,r]=e;return"["!==t||i.isNumeric(r)?`\n${e}`:e})).join(";\n")},M=e=>e.includes(";")?`'${e}'`:e,_=(...e)=>e.flatMap((e=>String(e).split("\n").map((e=>e.trim())).filter((e=>A.some((t=>e.match(t))))))),q=(e,t,...r)=>{let s="";const n=!!r.length,o=[],a=`${P.default.resolve("./")}/`;e.forEach((e=>{if(!i.isPopulatedString(e))return;const t=e.trim();"-"===t.slice(0,1)?(s&&o.push([s,""]),s=t.slice(1)):(s&&o.push([s,t.replaceAll(a,"")]),s="")}));const c=[];n&&t&&(c.push(`${t} failed`),c.push(..._(...r))),c.push("ffmpeg"),c.push(...o.map((([e,t])=>t?`-${e} ${L(t)}\n`:`-${e}\n`))),t&&c.push(t),n||o.unshift(["y",""]);const d=o.map((([e,t])=>t?`-${e} ${M(t)}`:`-${e}`));d.unshift("ffmpeg"),t&&d.push(t);const u=[c.join("\n")];return u.push(...r),u.push(d.join(" ")),u.join("\n\n")},N=e=>n.execSync(e).toString().trim(),z=e=>e?e.endsWith(i.ExtText)?H(e):e.startsWith("/")?N(e):e:"",H=e=>e?x.default.readFileSync(e).toString():"",U=e=>{if(!e)return{};if(e.endsWith(i.ExtJson))return U(H(e));switch(e[0]){case".":case"/":return U(z(e));case"{":return JSON.parse(e)}return{}};class W{static AlphaFormatsCommand="ffprobe -v 0 -of compact=p=0 -show_entries pixel_format=name:flags=alpha | grep 'alpha=1' | sed 's/.*=\\(.*\\)|.*/\\1/' ";static _alphaFormats;static get alphaFormats(){return this._alphaFormats||=this.alphaFormatsInitialize}static get alphaFormatsInitialize(){return N(this.AlphaFormatsCommand).split("\n")}static probeFile(e){const t=e.match(/%0([0-9]*)d/);if(!t)return e;const i=P.default.dirname(e),r=P.default.extname(e),[s,n]=t,o="0".repeat(Number(n)-1);return P.default.join(i,`${o}1${r}`)}static promise(e,t,r){const s=this.probeFile(t),n=P.default.relative("./",t),o=P.default.dirname(s);if(!x.default.existsSync(s))return Promise.reject(`${n} does not exist`);if(!x.default.statSync(s).size)return Promise.reject(`${n} is empty`);const a=r||P.default.join(o,`${P.default.basename(s)}.json`);if(x.default.existsSync(a))return x.default.promises.readFile(a).then((e=>JSON.parse(e.toString())));const c=j();return c.addInput(s),new Promise(((e,t)=>{x.default.promises.mkdir(P.default.dirname(a),{recursive:!0}).then((()=>{c.ffprobe(((t,r)=>{const n={audible:!1,...i.SizeZero,info:r,extension:P.default.extname(s).slice(1)};if(t)n.error=q(c._getArguments(),a,t);else{const{streams:e,format:t}=r,{duration:s=0}=t,o=[],a=[],c=[];for(const t of e){const{rotation:e,width:r,height:s,duration:d,codec_type:u,pix_fmt:h}=t;i.isPopulatedString(h)&&(n.alpha=this.alphaFormats.includes(h)),i.isNumeric(e)&&a.push(Math.abs(Number(e))),"audio"===u&&(n.audible=!0),i.isPositive(d)&&o.push(Number(d)),r&&s&&c.push({width:r,height:s})}if(s||o.length)if(o.length){const e=Math.max(...o);n.duration=s?Math.max(e,s):e}else n.duration=s;if(c.length){const e=a.some((e=>90===e||270===e)),t=e?"width":"height";n[e?"height":"width"]=Math.max(...c.map((e=>e.width))),n[t]=Math.max(...c.map((e=>e.height)))}}x.default.promises.writeFile(a,JSON.stringify(n)).then((()=>{e(n)}))}))}))}))}}const V={type:"basic"};class B{args;constructor(e){this.args=e}id="";init(e){return{}}startServer(e,t){const{authentication:i}=this.args;if("basic"===i?.type){const{password:t,users:r}=i,s={users:r,authorizer:(e,i)=>!(!e||!i)&&(!t||w.default.safeCompare(i,t)),challenge:!0,realm:"moviemasher"};e.use(`/${this.id}/*`,w.default(s),((e,t,i)=>{i()}))}}stopServer(){}userFromRequest(e){const t=e,{user:i}=t.auth;return i}}class J extends B{args;constructor(e){super(e),this.args=e}id="api";init(){return{}}activeServers={};callbacks=(e,t)=>{const i=e.body,{id:r}=i,s={},n=Object.keys(this.activeServers),[o,a]=r.split("/");n.includes(a)&&(s[r]={endpoint:{prefix:r}});const c={apiCallbacks:s};t.send(c)};servers=(e,t)=>{const i={};try{const t=this.userFromRequest(e);Object.entries(this.activeServers).forEach((([e,r])=>{i[e]=r.init(t)}))}catch(e){i.error=String(e)}t.send(i)};startServer(e,t){super.startServer(e,t),this.activeServers=t,e.post(i.Endpoints.api.callbacks,this.callbacks),e.post(i.Endpoints.api.servers,this.servers)}}const Z=()=>u.generateUUIDv4(),G=["id","label","icon"],Y=["*"],K=e=>{if(!e)return{};const{json:t,userId:i,...r}=e;return t?{...JSON.parse(t),...r}:r},Q=e=>{if(!e)return{};const{json:t,...i}=e;if(!t)return i;const r=JSON.parse(t);return Q({...r,...i})},X=e=>e.map(K),ee=(e,t)=>{const{userId:i,type:r,createdAt:s,icon:n,label:o,id:a,...c}=t,d={json:JSON.stringify(c),userId:e};return a&&(d.id=String(a)),s&&(d.createdAt=String(s)),n&&(d.icon=String(n)),o&&(d.label=String(o)),r&&(d.type=String(r)),d},te=(e,t)=>{t?.forEach((t=>{if(i.isLayerFolderObject(t))te(e,t.layers);else if(i.isLayerMashObject(t)){const{mash:r}=t,{id:s}=r,n=e.find((e=>e.id===s));if(!n)throw new Error(i.Errors.internal+"no mash with id "+s+" in "+e.map((e=>e.id)).join(", "));t.mash=n}}))};class ie extends B{args;constructor(e){super(e),this.args=e}castInsertPromise(e,t,i){const r={},{id:s}=t,n=s||Z(),o=n.startsWith(this.args.temporaryIdPrefix)?Z():n;o!==n&&(r[n]=o),t.id=o;return this.castUpdateRelationsPromise(e,t,i).then((t=>{const{cast:i,temporaryIdLookup:s}=t;return this.createPromise("`cast`",ee(e,i)).then((()=>({...s,...r})))})).then((e=>({...e,...e})))}castUpdatePromise(e,t,i){const{id:r}=t;if(!r)return Promise.reject(401);return this.castUpdateRelationsPromise(e,t,i).then((e=>{const{cast:t,temporaryIdLookup:i}=e;return this.updatePromise("`cast`",t).then((()=>i))}))}createPromise(e,t){t.createdAt||=(new Date).toISOString();const r=t.id||Z();i.assertPopulatedString(r);const s=r.startsWith(this.args.temporaryIdPrefix)?Z():r;t.id=s;const n=[],o=[];Object.entries(t).forEach((([e,t])=>{n.push(e),o.push(t)}));const a=((e,t)=>`\n    INSERT INTO ${e}\n    (${t.join(", ")})\n    VALUES(${Array(t.length).fill("?").join(", ")})\n  `)(e,n);return this.db.run(a,...o).then((()=>s))}_db;get db(){if(!this._db)throw i.Errors.internal+"db";return this._db}defaultCast=async(e,t)=>{const i=this.renderingServer?.args.previewSize,r={cast:{},definitions:[],previewSize:i};try{const t=this.userFromRequest(e),i=await this.getLatestPromise(t,"`cast`");if(i.id){const e=await this.selectCastRelationsPromise(i);r.definitions=e.definitions,r.cast=e.cast}}catch(e){r.error=String(e)}t.send(r)};defaultMash=async(e,t)=>{const i=this.renderingServer?.args.previewSize,r={mash:{},definitions:[],previewSize:i};try{const t=this.userFromRequest(e),i="\n        SELECT mash.* FROM mash \n        LEFT JOIN cast_mash \n        ON cast_mash.mashId = mash.id \n        WHERE cast_mash.mashId IS NULL\n        AND mash.userId = ? \n        ORDER BY createdAt DESC\n        LIMIT 1\n      ",s=await this.db.get(i,t).then((e=>{const{userId:i,...r}=Q(e);return i===t?r:{}}));s.id&&(r.mash=s,r.definitions=await this.selectMashRelationsPromise(String(s.id)))}catch(e){r.error=String(e)}t.send(r)};deleteCast=async(e,t)=>{const{id:i}=e.body,r={};try{const t=this.userFromRequest(e);await this.rowExists("`cast`",i,t)?await this.deletePromise("`cast`",i):r.error=`Could not find Cast with id: ${i}`}catch(e){r.error=String(e)}t.send(r)};deleteDefinition=async(e,t)=>{const{id:r}=e.body,s={};try{const t=this.userFromRequest(e);if(await this.rowExists("`mash`",r,t)){const e="SELECT * FROM mash_definition WHERE definitionId = ?",t=await this.db.all(e,r);t.length?(s.mashIds=t.map((e=>e.mashid)),s.error=`Referenced by ${i.stringPluralize(t.length,"mash","es")}`):await this.deletePromise("`definition`",r)}else s.error=`Could not find Definition with id: ${r}`}catch(e){s.error=String(e)}t.send(s)};deleteMash=async(e,t)=>{const{id:r}=e.body,s={};try{const t=this.userFromRequest(e);if(await this.rowExists("`mash`",r,t)){const e="SELECT * FROM cast_mash WHERE mashId = ?",t=await this.db.all(e,r);t.length?(s.castIds=t.map((e=>e.castId)),s.error=`Referenced by ${i.stringPluralize(t.length,"cast")}`):await this.deletePromise("`mash`",r)}else s.error=`Could not find Mash with id: ${r}`}catch(e){s.error=String(e)}t.send(s)};deletePromise(e,t){const r=`DELETE FROM ${e} WHERE id = ?`;return this.db.run(r,t).then(i.EmptyMethod)}fileServer;getCast=async(e,t)=>{const{id:i}=e.body,r={cast:{},definitions:[]};try{const t=this.userFromRequest(e),s=await this.jsonPromise("`cast`",t,i);if(s){const e=await this.selectCastRelationsPromise(s);r.definitions=e.definitions,r.cast=e.cast}else r.error=`Could not find cast ${i}`}catch(e){r.error=String(e)}t.send(r)};getDefinition=async(e,t)=>{const{id:i}=e.body,r={definition:{}};try{const t=this.userFromRequest(e),s=await this.jsonPromise("`definition`",t,i);s?r.definition=s:r.error=`Could not find definition ${i}`}catch(e){r.error=String(e)}t.send(r)};getLatestPromise(e,t){const i=`SELECT * FROM ${t} WHERE userId = ? ORDER BY createdAt DESC`;return this.db.get(i,e).then((t=>{const{userId:i,...r}=Q(t);return i===e?r:{}}))}getMash=async(e,t)=>{const{id:i}=e.body,r={mash:{},definitions:[]};try{const t=this.userFromRequest(e),s=await this.jsonPromise("`mash`",t,i);s.id!==i?r.error=`Could not find mash ${i}`:(r.mash=s,r.definitions=await this.selectMashRelationsPromise(i))}catch(e){r.error=String(e)}t.send(r)};id="data";init(){return{temporaryIdPrefix:this.args.temporaryIdPrefix}}insertDefinitionPromise(e,t){return this.createPromise("`definition`",ee(e,t))}jsonPromise(e,t,i){return!i||i.startsWith(this.args.temporaryIdPrefix)?Promise.resolve():this.db.get(((e,t=Y)=>`SELECT ${t.join(", ")} FROM ${e} WHERE id = ?`)(e),i).then(Q).then((e=>{if(!e)return;const{userId:i,...r}=e;return i===t?r:void 0}))}mashInsertPromise(e,t,i){const r={},{id:s}=t,n=s||Z();t.id=n;return this.createPromise("`mash`",ee(e,t)).then((e=>(e!==n&&(r[n]=e),this.mashUpdateRelationsPromise(e,i)))).then((()=>r))}mashUpdatePromise(e,t,i){const{createdAt:r,icon:s,id:n,label:o,...a}=t;if(!n)return Promise.reject(401);const c=JSON.stringify(a),d={userId:e,createdAt:r,icon:s,id:n,label:o,json:c};return this.updatePromise("`mash`",d).then((()=>this.mashUpdateRelationsPromise(n,i)))}putCast=async(e,t)=>{const{cast:i,definitionIds:r}=e.body,s={};try{const t=this.userFromRequest(e);s.temporaryIdLookup=await this.writeCastPromise(t,i,r)}catch(e){s.error=String(e)}t.send(s)};putDefinition=async(e,t)=>{const{definition:i}=e.body,r={id:""};try{const t=this.userFromRequest(e);r.id=await this.writeDefinitionPromise(t,i)}catch(e){r.error=String(e)}t.send(r)};putMash=async(e,t)=>{const{mash:i,definitionIds:r}=e.body,s={};try{const t=this.userFromRequest(e);s.temporaryIdLookup=await this.writeMashPromise(t,i,r)}catch(e){s.error=String(e)}t.send(s)};renderingServer;retrieveCast=async(e,t)=>{const{partial:i}=e.body,r={described:[]};try{const t=this.userFromRequest(e),s=i?G:Y;r.described=await this.selectCastsPromise(t,s)}catch(e){r.error=String(e)}t.send(r)};retrieveDefinition=async(e,t)=>{const i=e.body,{partial:r,types:s}=i,n={definitions:[]};try{const t=this.userFromRequest(e),i=r?G:Y;n.definitions=await this.selectDefinitionsPromise(t,s,i)}catch(e){n.error=String(e)}t.send(n)};retrieveMash=async(e,t)=>{const{partial:i}=e.body,r={described:[]};try{const t=this.userFromRequest(e),s=i?G:Y;r.described=await this.selectMashesPromise(t,s)}catch(e){r.error=String(e)}t.send(r)};rowExists(e,t,i){return new Promise(((r,s)=>{this.userIdPromise(e,t).then((e=>e&&e!==i?s(403):r(!!e)))}))}selectCastsPromise(e,t=Y){const i=`SELECT ${t.join(", ")} FROM \`cast\` WHERE userId = ?`;return this.db.all(i,e).then(X)}selectDefinitionsPromise(e,t,i=Y){const r=`\n      SELECT ${i.join(", ")}\n      FROM \`definition\`\n      WHERE (${Array(t.length).fill("type = ?").join(" OR ")})\n      AND (userId = '' OR userId = ?)\n    `;return this.db.all(r,...t,e).then(X)}selectCastRelationsPromise(e){const{id:t}=e;i.assertPopulatedString(t);return this.db.all("\n      SELECT mash.*\n      FROM cast_mash\n      JOIN mash\n      ON mash.id = mashId\n      WHERE castId = ?\n    ",t).then(X).then((t=>{te(t,e.layers);const r={cast:e,definitions:[]};let s=Promise.resolve(r);return t.forEach((e=>{const{id:t}=e;i.assertPopulatedString(t),s=s.then((e=>this.selectMashRelationsPromise(t).then((t=>(e.definitions.push(...t),e)))))})),s}))}selectMashRelationsPromise(e){return this.db.all("\n      SELECT definition.*\n      FROM mash_definition\n      JOIN definition\n      ON definition.id = definitionId\n      WHERE mashId = ?\n    ",e).then(X)}selectMashesPromise(e,t=Y){const i=`SELECT \n      ${t.map((e=>`\`mash\`.${e}`)).join(", ")} \n      FROM \`mash\` \n      LEFT JOIN cast_mash\n      ON cast_mash.mashId = \`mash\`.id\n      WHERE cast_mash.mashId IS NULL\n      AND userId = ?\n    `;return this.db.all(i,e).then(X)}startDatabase(){const{dbPath:e,dbMigrationsPrefix:t}=this.args;console.debug(this.constructor.name,"startDatabase",e),x.default.mkdirSync(P.default.dirname(e),{recursive:!0}),c.open({filename:e,driver:E.default.Database}).then((e=>{this._db=e,t&&(console.debug(this.constructor.name,"startDatabase migrating...",t),this.db.migrate({migrationsPath:t}).catch((e=>console.error(this.constructor.name,"startDatabase migration failed",e))))}))}startServer(e,t){super.startServer(e,t),this.fileServer=t.file,this.renderingServer=t.rendering,e.post(i.Endpoints.data.cast.default,this.defaultCast),e.post(i.Endpoints.data.cast.delete,this.deleteCast),e.post(i.Endpoints.data.cast.get,this.getCast),e.post(i.Endpoints.data.cast.put,this.putCast),e.post(i.Endpoints.data.cast.retrieve,this.retrieveCast),e.post(i.Endpoints.data.definition.delete,this.deleteDefinition),e.post(i.Endpoints.data.definition.get,this.getDefinition),e.post(i.Endpoints.data.definition.retrieve,this.retrieveDefinition),e.post(i.Endpoints.data.definition.put,this.putDefinition),e.post(i.Endpoints.data.mash.default,this.defaultMash),e.post(i.Endpoints.data.mash.delete,this.deleteMash),e.post(i.Endpoints.data.mash.get,this.getMash),e.post(i.Endpoints.data.mash.put,this.putMash),e.post(i.Endpoints.data.mash.retrieve,this.retrieveMash),this.startDatabase()}stopServer(){this._db?.close()}updatePromise(e,t){const{id:r,...s}=t,n=[],o=[];Object.entries(s).forEach((([e,t])=>{n.push(e),o.push(t)}));const a=((e,t)=>`\n    UPDATE ${e}\n    SET ${t.map((e=>`${e} = ?`)).join(", ")}\n    WHERE id = ?\n  `)(e,n);return this.db.run(a,...o,r).then(i.EmptyMethod)}castUpdateRelationsPromise(e,t,r){const s={},{createdAt:n,icon:o,id:a,label:c,...d}=t;i.assertPopulatedString(a);const{layers:u=[]}=t,h=e=>{const{temporaryIdPrefix:t}=this.args;return e.flatMap((e=>{if(i.isLayerMashObject(e)){const{mash:r}=e,n=r.id;i.assertPopulatedString(n);const o=n.startsWith(t)?Z():n;return n!==o&&(s[n]=o,r.id=o),e.mash={id:o},[r]}if(i.isLayerFolderObject(e)){const{layers:t}=e;if(t)return h(t)}return[]}))},p=h(u);let l=Promise.resolve(s);const m=p.map((e=>e.id));return p.forEach((t=>{const i=t.id,s=r?r[i]:[];l=l.then((i=>this.writeMashPromise(e,t,s).then((e=>({...i,...e})))))})),l.then((e=>this.updateRelationsPromise("cast","mash",a,m).then((t=>{const i=JSON.stringify(d);return{cast:{createdAt:n,icon:o,id:a,label:c,json:i},temporaryIdLookup:{...t,...e}}}))))}updateDefinitionPromise(e){const{type:t,createdAt:r,icon:s,id:n,label:o,...a}=e;if(!n)return Promise.reject(401);const c={createdAt:r,icon:s,id:n,label:o,json:JSON.stringify(a)};return this.updatePromise("`definition`",c).then(i.EmptyMethod)}mashUpdateRelationsPromise(e,t){return this.updateRelationsPromise("mash","definition",e,t)}updateRelationsPromise(e,t,r,s){const n={};if(!s)return Promise.resolve(n);const o=s.map((e=>e.startsWith(this.args.temporaryIdPrefix)?n[e]=Z():e)),a=`${e}_${t}`,c=`${e}Id`,d=`${t}Id`,u=`SELECT * FROM ${a} WHERE ${c} = ?`;return this.db.all(u,r).then((e=>{const t=[],s=[];e.forEach((e=>{const i=String(e[d]);o.includes(i)?s.push(i):t.push(e.id)}));const n=o.filter((e=>!s.includes(e))),u=[...t.map((e=>this.deletePromise(a,e))),...n.map((e=>this.createPromise(a,{[d]:e,[c]:r}).then(i.EmptyMethod)))];switch(u.length){case 0:return Promise.resolve();case 1:return u[0];default:return Promise.all(u).then(i.EmptyMethod)}})).then((()=>n))}userIdPromise(e,t){return this.db.get(`SELECT userId FROM ${e} WHERE id = ?`,t).then((e=>e?.userId||""))}writeCastPromise(e,t,i){const{id:r}=t;return this.jsonPromise("`cast`",e,r).then((r=>r?(Object.assign(r,t),this.castUpdatePromise(e,r,i)):this.castInsertPromise(e,t,i)))}writeDefinitionPromise(e,t){const{id:i}=t;return i?this.rowExists("`definition`",i,e).then((r=>r?this.updateDefinitionPromise(t).then((()=>i)):this.insertDefinitionPromise(e,t))):this.insertDefinitionPromise(e,t)}writeMashPromise(e,t,i){const{id:r}=t;return this.jsonPromise("`mash`",e,r).then((r=>r?(Object.assign(r,t),this.mashUpdatePromise(e,r,i)):this.mashInsertPromise(e,t,i)))}}class re extends B{args;constructor(e){super(e),this.args=e}constructCallback(e,t,r){const s={id:r};return{endpoint:{prefix:i.Endpoints.file.store},request:{body:s,headers:{"Content-Type":"multipart/form-data"}}}}get extensions(){return Object.values(this.args.extensions).flat()}extensionLoadType(e){return i.UploadTypes.find((t=>this.args.extensions[t].includes(e)))}id="file";init(e){const t=`/${P.default.join(this.args.uploadsRelative,e)}/`,{extensions:i,uploadLimits:r}=this.args;return{prefix:t,extensions:i,uploadLimits:r}}property="file";startServer(e,t){super.startServer(e,t);const r=1048576*Math.max(...Object.values(this.args.uploadLimits)),{uploadsPrefix:s}=this.args,{extensions:n}=this,o={storage:C.default.diskStorage({destination:function(e,t,r){const{id:n}=e.body,o=e,{user:a}=o.auth;if(a){const e=`${s}/${a}/${n}`;x.default.mkdirSync(e,{recursive:!0}),r(null,e)}else r(new Error(i.Errors.invalid.user),"")},filename:function(e,t,i){const{originalname:r}=t,s=P.default.extname(r).slice(1).toLowerCase();n.includes(s)?i(null,`original.${s}`):i(new Error(`Invalid extension ${s}`),"")}}),limits:{fileSize:r}},a=C.default(o);e.post(i.Endpoints.file.store,a.single(this.property),this.store)}store=async(e,t)=>{const r=e.body,s={};try{if(this.userFromRequest(e)){const{id:t}=r;if(t){const{file:t}=e;t||(s.error="No file supplied")}else s.error=i.Errors.id}else s.error=i.Errors.invalid.user}catch(e){s.error=String(e)}t.send(s)};userUploadPrefix(e,t){return i.assertPopulatedString(e,"upload id"),e}withinLimits(e,t){if(!e)throw i.Errors.invalid.size;if(!t)throw i.Errors.invalid.type;const r=this.args.uploadLimits[t];if(!r)throw i.Errors.invalid.type;return r>e/1048576}}class se extends T.default{constructor(e,t){super(),this.id=e;const{commandFilters:r,inputs:s,output:n,avType:o}=t;if(this.avType=o,r&&(this.commandFilters=r),s&&(this.commandInputs=s),!this.commandInputs.length&&!this.commandFilters.length)throw console.trace(this.constructor.name,"with no inputs or commandFilters"),i.Errors.invalid.argument+"inputs";this.output=n}_commandProcess;get command(){if(this._commandProcess)return this._commandProcess;const{commandInputs:e,commandFilters:t,output:i,avType:r}=this,s={commandFilters:t,inputs:e,output:i,avType:r};return this._commandProcess=k(s)}avType;commandFilters=[];id;commandInputs=[];kill(){console.debug(this.constructor.name,"kill",this.id),this._commandProcess?.kill("SIGKILL")}makeDirectory(e){x.default.mkdirSync(P.default.dirname(e),{recursive:!0})}output={};run(e){this.command.on("error",((...t)=>{const r=i.isPopulatedString(e)?e:"",s=this.runError(r,...t);console.error(this.constructor.name,"run on error",s),this.emit("error",s)})),this.command.on("start",((...e)=>{this.emit("start",...e)})),this.command.on("end",((...e)=>{this.emit("end",...e)})),i.isPopulatedString(e)&&this.makeDirectory(e);try{this.command.output(e),this.command.run()}catch(e){console.error(this.constructor.name,"run received error",e)}}runError(e,...t){return q(this.command._getArguments(),e,...t)}runPromise(e){i.assertPopulatedString(e);const t={};return new Promise(((i,r)=>{const{command:s}=this;s.on("error",((...t)=>{r({error:this.runError(e,...t)})})),s.on("end",(()=>{i(t)}));try{this.makeDirectory(e),s.save(e)}catch(t){r({error:this.runError(e,t)})}}))}}const ne={},oe=e=>ne[e],ae=e=>{const t=oe(e);t&&(delete ne[e],t.kill())},ce=(e,t)=>{const i=new se(e,t);return ne[e]=i,i};class de extends i.LoaderClass{temporaryDirectory;cacheDirectory;filePrefix;defaultDirectory;validDirectories;constructor(e,t,r,s,n){if(super(),this.temporaryDirectory=e,this.cacheDirectory=t,this.filePrefix=r,this.defaultDirectory=s,this.validDirectories=n,!t)throw i.Errors.invalid.url+"cacheDirectory";if(!r)throw i.Errors.invalid.url+"filePrefix";if(!s)throw i.Errors.invalid.url+"defaultDirectory"}browsing=!1;cachePromise(e,t,r){if(x.default.existsSync(e))return this.updateSources(e,r,t);const{filePrefix:s}=this;if(e.startsWith(s))throw i.Errors.uncached+" cachePromise "+e;return this.writePromise(t,e).then((()=>this.updateSources(e,r,t)))}graphType=i.GraphType.Mash;graphFileTypeBasename(e,t){if(e!==i.GraphFileType.SvgSequence)return`cached.${e}`;const r=t.split("\n").length;return`%0${String(r).length}.svg`}infoPath(e){return P.default.join(this.cacheDirectory,`${$.default(e)}.info.txt`)}key(e){const{type:t,file:r,content:s,resolved:n}=e;if(n)return n;i.assertPopulatedString(r,"file");const{cacheDirectory:o,filePrefix:a,defaultDirectory:c,validDirectories:d}=this;if(!i.isLoadType(t)){t||console.trace(this.constructor.name,"key NOT LOADTYPE",t,r,s),i.assertPopulatedString(s,"content");const e=this.graphFileTypeBasename(t,s);return P.default.resolve(o,r,e)}if(r.includes("://")){const e=P.default.extname(r)||this.typeExtension(t);return P.default.resolve(o,$.default(r),`cached${e}`)}const u=P.default.resolve(a,c,r),h=[c,...d];if(![P.default.resolve(o),...h.map((e=>P.default.resolve(a,e)))].some((e=>u.startsWith(e))))throw i.Errors.invalid.url+u;return e.resolved=u,u}loadGraphFilePromise(e){let t=this.cacheGet(e,!0);i.assertObject(t);const{definition:r}=e;if(i.isDefinition(r)){const{definitions:e}=t;e.includes(r)||e.push(r)}const{promise:s}=t;return i.assertObject(s),s}remoteLocalFile(e,t,r){if(!i.isPopulatedString(r)||r.startsWith(t))return e;if(t!==i.LoadType.Font||!r.startsWith("text/css"))return e;const s=P.default.dirname(e),n=P.default.extname(e),o=P.default.basename(e,n);return P.default.join(s,`${o}.css`)}remotePromise(e,t,i){const r=new Promise(((r,s)=>{const{request:n}=i.startsWith("https")?F.default:O.default,o=n(i,(i=>{const{"content-type":n}=i.headers,o=this.remoteLocalFile(t,e,n),a=x.default.createWriteStream(o);i.pipe(a),a.on("finish",(()=>{a.close(),o===t?r():x.default.promises.readFile(o).then((i=>{const s=i.toString(),n=this.lastCssUrl(s);this.remotePromise(e,t,n).then(r)}))})),a.on("error",(e=>{console.error(this.constructor.name,"remotePromise.callback error",e),s(e)}))}));o.on("error",(e=>{console.error(e),s(e)})),o.end()}));return r}typeExtension(e){switch(e){case i.LoadType.Font:return".ttf";case i.LoadType.Image:return".png";case i.LoadType.Audio:return".mp3";case i.LoadType.Video:return".mp4"}}updateableDefinitions(e){return[...e.definitions].filter((e=>i.isPreloadableDefinition(e))).filter((e=>!(!i.isUpdatableDurationDefinition(e)||i.isAboveZero(e.duration))||i.isUpdatableSizeDefinition(e)&&!i.sizeAboveZero(e.sourceSize)))}updateSources(e,t,r){const{definitions:s}=t;t.loaded=!0,s.forEach((t=>{i.isPreloadableDefinition(t)&&(t.source.startsWith("http")||(t.source=e))}));const{type:n}=r;if(!i.isLoadType(n))return Promise.resolve();if(!this.updateableDefinitions(t).length)return Promise.resolve();const o=this.infoPath(e),{temporaryDirectory:a}=this;return W.promise(a,e,o).then((e=>{this.updateDefinitions(r,e)}))}writePromise(e,t){const{file:r,type:s,content:n}=e,o=P.default.dirname(t);let a=x.default.promises.mkdir(o,{recursive:!0}).then(i.EmptyMethod);if(i.isLoadType(s)){if(i.urlIsHttp(r))return a.then((()=>this.remotePromise(s,t,r)));throw i.Errors.uncached+r}return i.assertPopulatedString(n),s===i.GraphFileType.SvgSequence?a.then((()=>{const e=n.split("\n"),{length:t}=e,r=String(t).length;return Promise.all(e.map(((e,t)=>{const i=`${String(t).padStart(r,"0")}.svg`,s=P.default.join(o,i);return x.default.promises.writeFile(s,e)}))).then(i.EmptyMethod)})):a.then((()=>x.default.promises.writeFile(t,n)))}}const ue=(e,t={})=>{const{type:r,id:s}=e,n={...e,type:r===i.DefinitionType.VideoSequence?i.DefinitionType.Video:r},o=[n];return{mash:{...{id:s},tracks:[{dense:!0,clips:[le(n,t)]}]},definitions:o}},he=e=>{const t={};return e.map((e=>{const{outputType:r}=e,s=i.outputDefaultPopulate(e);return t[r]?(s.basename||=`${r}-${t[r]}`,t[r]++):t[r]=1,s}))},pe=(e,t,r)=>{const{basename:s,format:n,extension:o,outputType:a}=t,c=r||o||n;i.assertPopulatedString(c);const d=[s||a];return e&&!s&&d.push(String(e)),d.push(c),d.join(".")},le=(e,t={})=>{const{id:r,type:s}=e,{id:n,containerId:o,...a}=t,c=r||s,d=o?String(o):void 0,u="audio"===s?"":d,h={definitionId:i.clipDefault.id,contentId:c,content:{...a},containerId:u};return s===i.DefinitionType.Image&&(h.timing=i.Timing.Custom,h.frames=1),h},me=(e,t,i,r)=>{const s=fe(e);return{id:i||Z(),type:s,source:t,label:r}},fe=e=>{switch(e){case i.LoadType.Audio:return i.DefinitionType.Audio;case i.LoadType.Video:return i.DefinitionType.VideoSequence;case i.LoadType.Image:return i.DefinitionType.Image;case i.LoadType.Font:return i.DefinitionType.Font}};class ge{args;constructor(e){this.args=e,i.Defined.define(...this.args.definitions)}combinedRenderingDescriptionPromise(e,t){const{visibleCommandDescriptions:r,commandOutput:s,audibleCommandDescription:n}=t,o=r?.length;if(!o||1===o)return Promise.resolve(t);const a=i.ExtTs,{options:c={},audioBitrate:d,audioChannels:u,audioCodec:h,audioRate:p,outputType:l,...m}=s,f={...m,options:{...c,an:"",qp:0},extension:a,outputType:i.OutputType.Video},{outputDirectory:g}=this.args,y=pe(e,s,"concat"),S=P.default.join(g,y);let v=this.createDirectoryPromise(S);const b=r.map(((e,t)=>{const r=`concat-${t}`,s=`${r}.${a}`,n=P.default.join(S,s),o=P.default.join(S,`${r}.commands.txt`),c=P.default.join(S,`${r}.info.txt`),{duration:d}=e;i.assertAboveZero(d,"duration");const u=[s,d];return v=v.then((()=>this.renderResultPromise(n,o,c,f,e).then(i.EmptyMethod))),u})),x=this.concatFile(b),D=P.default.join(S,"concat.txt");return v=v.then((()=>this.createFilePromise(D,x))),v.then((()=>{i.assertSize(f);const{width:e,height:t}=f,r={source:D},o=b.map((([e,t])=>t)),a=o.reduce(((e,t)=>e+t),0),d=n?.inputs||[],u={inputs:[r],duration:a,avType:i.AVType.Video};d.length&&(u.commandFilters=[{inputs:[`${d.length}:v`],ffmpegFilter:"copy",options:{},outputs:[]}]);return{audibleCommandDescription:n,visibleCommandDescriptions:[u],commandOutput:{...s,width:e,height:t,options:{...c,"c:v":"copy"}}}}))}commandDescriptionMerged(e){const{visibleCommandDescriptions:t,audibleCommandDescription:r}=e,s=[],n=t?.length;if(n){i.assertTrue(1===n,"flat");const[e]=t;s.push(e)}if(r&&s.push(r),!s.length)return;const[o]=s;return s.length>1?this.commandDescriptionsMerged(s):o}commandDescriptionsMerged(e){const t=[],r=[],s=[],n=new Set;e.forEach((e=>{const{duration:i,inputs:o,commandFilters:a,avType:c}=e;n.add(c),o&&t.push(...o),a&&r.push(...a),i&&s.push(i)}));const o=1===n.size?[...n.values()].pop():i.AVType.Both,a={inputs:t,commandFilters:r,avType:o};return i.assertTrue(s.length===e.length,"each description has duration"),a.duration=Math.max(...s),a}concatFile(e){const t=["ffconcat version 1.0"];return t.push(...e.flatMap((e=>{const[t,i]=e;return[`file '${t}'`,`duration ${i}`]}))),t.join("\n")}createDirectoryPromise(e){return x.default.promises.mkdir(e,{recursive:!0}).then(i.EmptyMethod)}createFilePromise(e,t){return x.default.promises.writeFile(e,t).then(i.EmptyMethod)}directoryPromise(){const{outputsPopulated:e,args:t,id:i}=this,{outputDirectory:r,mash:s,definitions:n,upload:o}=t,a=JSON.stringify({id:i,outputs:e,mash:s,definitions:n,upload:o},null,2);return this.createDirectoryPromise(r).then((()=>{const e=P.default.join(r,"rendering.json");return this.createFilePromise(e,a)}))}fileName(e,t,r){const{outputType:s,videoRate:n}=t;if(s!==i.OutputType.ImageSequence)return pe(e,t);if(!n)throw i.Errors.internal+"videoRate";const{format:o,extension:a,basename:c}=t,d=c||"",u=a||o,{duration:h}=r,p=Math.floor(n*h)-2;return`${d}%0${String(p-1+1).length}d.${u}`}_id;get id(){return this._id?this._id:this._id=this.args.id||i.idGenerateString()}_mashInstance;get mashInstance(){if(this._mashInstance)return this._mashInstance;const{args:e,preloader:t}=this,{mash:r}=e,s={...r,preloader:t};return this._mashInstance=i.mashInstance(s)}outputInstance(e){const{outputType:t}=e,{cacheDirectory:r,upload:s}=this.args,{mashInstance:n}=this,o={commandOutput:e,cacheDirectory:r,mash:n,upload:s};return i.OutputFactory[t](o)}_outputsPopulated;get outputsPopulated(){return this._outputsPopulated||=he(this.args.outputs)}_preloader;get preloader(){return this._preloader||=this.preloaderInitialize}get preloaderInitialize(){const{args:e}=this,{cacheDirectory:t,validDirectories:i,defaultDirectory:r,filePrefix:s,temporaryDirectory:n}=e;return new de(n,t,s,r,i)}renderResultPromise(e,t,r,s,n){const{outputType:o,avType:a}=s,{duration:c,inputs:d}=n,u={output:s,...n},h=s.options;switch(o){case i.OutputType.Image:case i.OutputType.Waveform:h["frames:v"]=1;break;default:c&&(h.t=c)}a===i.AVType.Audio?(delete s.videoCodec,delete s.videoRate):a===i.AVType.Video&&(delete s.audioCodec,delete s.audioBitrate,delete s.audioChannels,delete s.audioRate);const p=ce(this.id,u),l=q(p.command._getArguments(),e);return x.default.promises.writeFile(t,l).then((()=>p.runPromise(e))).then((t=>{const i={...t,destination:e,outputType:o},{error:s}=t;if(s)return x.default.promises.writeFile(r,JSON.stringify(i)).then((()=>i));const{temporaryDirectory:n}=this.args;return W.promise(n,e,r).then((()=>i))}))}rendered(e,t=0,r=.1){if(!x.default.existsSync(e))return!1;if(!t)return!0;const s=P.default.dirname(e),n=P.default.extname(e),o=P.default.basename(e,n),a=P.default.join(s,`${o}.info.txt`);if(!x.default.existsSync(a))return!1;const c=x.default.readFileSync(a);if(!i.isDefined(c))return!1;const d=JSON.parse(c.toString()),u=Math.round(d.duration/r),h=Math.round(t/r),p=u===h;return p||console.log(this.constructor.name,"rendered",u,p?"===":"!==",h),p}runPromise(){const e=[],t={runResult:{results:e},countsByType:{}};let r=this.directoryPromise().then((()=>t));const{outputsPopulated:s}=this,{outputDirectory:n,upload:o}=this.args;return s.forEach((t=>{const{optional:s,outputType:o}=t,a={options:{},...t},c=o!==i.OutputType.Image,d=this.outputInstance(a);r=r.then((t=>{const{countsByType:r}=t;i.isDefined(r[o])||(r[o]=-1),r[o]++;const a=r[o];return d.renderingDescriptionPromise(e).then((e=>this.combinedRenderingDescriptionPromise(a,e))).then((t=>{const{commandOutput:r}=t,u=pe(a,r,"info.txt"),h=P.default.join(n,u),p=this.commandDescriptionMerged(t);if(!p){if(!s)throw`required ${o} failed`;e.push({outputType:o});const t={warning:`found no ${o}`};return x.default.promises.writeFile(h,JSON.stringify(t))}if(c){const{duration:e,inputs:t}=p;if(!e)throw i.Errors.invalid.duration}const l=pe(a,r,"commands.txt"),m=this.fileName(a,r,d),f=P.default.join(n,l),g=P.default.join(n,m);return this.renderResultPromise(g,f,h,r,p).then((t=>{e.push(t)}))})).then((()=>t))}))})),r.then((({runResult:e})=>{if(o){const[t]=this.mashInstance.tracks[0].clips,{contentId:r}=t,s=i.Defined.fromId(r);if(i.isPreloadableDefinition(s)){const{source:t,loadType:r}=s,{preloader:n,args:o}=this,{outputDirectory:a}=o,c={input:!0,definition:s,type:r,file:t};i.assertLoadType(r);const d=n.key(c),u=n.infoPath(d);if(x.default.existsSync(u))return x.default.promises.copyFile(u,P.default.join(a,"upload.info.txt")).then((()=>e))}}return e}))}}const ye=e=>new ge(e);class Se extends B{args;constructor(e){super(e),this.args=e}dataPutCallback(e,t,r,s,n){const o=this.definitionFilePath(t,r);if(e){i.assertTrue(x.default.existsSync(o),o);const e=H(o),r=JSON.parse(e);this.populateDefinition(t,s,r,n);return{endpoint:{prefix:i.Endpoints.data.definition.put},request:{body:{definition:r}}}}const[a]=n,c={id:r,rendering:`${r}/${s}/${a.outputType}.${a.extension||a.format}`};return{endpoint:{prefix:i.Endpoints.data.mash.put},request:{body:{mash:c}}}}definitionFilePath(e,t){const i=this.outputDirectory(e,t);return P.default.join(i,"definition.json")}definitionTypeCommandOutputs(e){const t=[],{previewSize:r,iconSize:s}=this;switch(e){case i.DefinitionType.Audio:t.push({outputType:i.OutputType.Audio});break;case i.DefinitionType.Image:t.push({outputType:i.OutputType.Image,...r}),t.push({outputType:i.OutputType.Image,...s,basename:"icon"});break;case i.DefinitionType.VideoSequence:t.push({outputType:i.OutputType.Audio,optional:!0}),t.push({outputType:i.OutputType.Image,...s,basename:"icon"}),t.push({outputType:i.OutputType.ImageSequence,...r});case i.DefinitionType.Font:}return t}directoryPromise(e,t){const{id:i}=t,r=this.definitionFilePath(e,i),s=P.default.dirname(r);return x.default.promises.mkdir(s,{recursive:!0}).then((()=>x.default.promises.writeFile(r,JSON.stringify(t,null,2))))}fileServer;id="rendering";outputDirectory(e,t,i){const r=[this.fileServer.args.uploadsPrefix];return e&&r.push(e),t&&r.push(t),i&&r.push(i),P.default.resolve(...r)}populateDefinition(e,t,r,s){const{fileServer:n}=this;i.assertTrue(n);const{id:o,source:a,type:c}=r;i.assertPopulatedString(o),i.assertDefinitionType(c),i.assertPopulatedString(a);const d=P.default.join(n.userUploadPrefix(o,e),t),u=this.outputDirectory(e,o),h=P.default.join(u,t,"upload.info.txt"),p=x.default.existsSync(h)?U(h):{},{width:l,height:m,duration:f,audible:g,label:y}=p;i.isUpdatableDurationType(c)&&i.isAboveZero(f)&&(r.duration=f),i.isUpdatableSizeType(c)&&i.isAboveZero(l)&&i.isAboveZero(m)&&(r.sourceSize={width:l,height:m});const S={};s.forEach((e=>{const{outputType:s}=e;i.isDefined(S[s])||(S[s]=-1),S[s]++;const n=S[s],o=pe(n,e,"info.txt"),a=P.default.join(u,t,o),h=U(a),{width:p,height:l,duration:m,audible:f,extension:g}=h,y=pe(n,e,g),v=P.default.join(d,y);switch(s){case i.OutputType.ImageSequence:i.isAboveZero(p)&&i.isAboveZero(l)&&(r.fps=e.videoRate,r.previewSize={width:p,height:l},r.url=d+"/");break;case i.OutputType.Audio:{const{duration:e}=r;if(i.isAboveZero(m)&&i.isAboveZero(e)){r.audio=!0,r.duration=Math.min(e,m);c===i.DefinitionType.Audio?r.url=v:r.audioUrl=v}break}case i.OutputType.Image:if(i.isAboveZero(p)&&i.isAboveZero(l)){const e={width:p,height:l};c===i.DefinitionType.Image&&!n?(r.previewSize=e,r.url=v):r.icon=v}}}))}get previewSize(){return this.args.previewSize||i.SizePreview}get outputSize(){return this.args.outputSize||i.SizeOutput}get iconSize(){return this.args.iconSize||i.SizeIcon}_renderingCommandOutputs;get renderingCommandOutputs(){if(this._renderingCommandOutputs)return this._renderingCommandOutputs;const{previewSize:e,outputSize:t}=this,r=this.args.commandOutputs||{},s=Object.fromEntries(i.OutputTypes.map((s=>{const n={outputType:s};switch(s){case i.OutputType.Image:case i.OutputType.ImageSequence:n.width=e.width,n.height=e.height,n.cover=!0;break;case i.OutputType.Video:n.width=t.width,n.height=t.height}const o=r[s]||{};return[s,{...n,...o}]})));return this._renderingCommandOutputs=s}start=async(e,t)=>{const r=e.body,{mash:s={},outputs:n=[],definitions:o=[],upload:a=!1,...c}=r,d=n.map((e=>{const{outputType:t}=e,r={...this.renderingCommandOutputs[t],...e};return i.outputDefaultPopulate(r)})),u=s.id||Z(),h=Z(),p={apiCallback:this.statusCallback(u,h)};try{const t=this.userFromRequest(e),{cacheDirectory:i,temporaryDirectory:r}=this.args,n=this.fileServer.args.uploadsPrefix,p=this.outputDirectory(t,u,h),l={...c,upload:a,mash:s,defaultDirectory:t,validDirectories:["shared"],cacheDirectory:i,temporaryDirectory:r,outputDirectory:p,filePrefix:n,definitions:o,outputs:d};ye(l).runPromise()}catch(e){p.error=String(e)}t.send(p)};startCallback(e){const{id:t,type:r}=e;if(!t)throw i.Errors.id;i.assertDefinitionType(r);const s=this.definitionTypeCommandOutputs(r),n={body:{...ue(e,{}),outputs:s,upload:!0}};return{endpoint:{prefix:i.Endpoints.rendering.start},request:n}}status=async(e,t)=>{const r=e.body,{id:s,renderingId:n}=r,o={};try{const t=this.userFromRequest(e),r=this.outputDirectory(t,s,n),a=P.default.join(r,"rendering.json"),c=H(a),d=JSON.parse(c),{outputs:u,upload:h}=d,p=x.default.readdirSync(r),l={},m=u.map((e=>{const{outputType:t}=e;i.isDefined(l[t])||(l[t]=-1),l[t]++;const r=l[t];o[t]||={total:0,completed:0};const s=o[t];s.total++;const n=pe(r,e,"info.txt");return p.includes(n)?(s.completed++,0):1}));Math.max(...m)?o.apiCallback=this.statusCallback(s,n):o.apiCallback=this.dataPutCallback(!!h,t,s,n,u)}catch(e){o.error=String(e)}t.send(o)};statusCallback(e,t){return{endpoint:{prefix:i.Endpoints.rendering.status},request:{body:{id:e,renderingId:t}}}}startServer(e,t){super.startServer(e,t),this.fileServer=t.file,this.fileServer&&e.post(i.Endpoints.rendering.upload,this.upload),e.post(i.Endpoints.rendering.start,this.start),e.post(i.Endpoints.rendering.status,this.status)}upload=async(e,t)=>{const r=e.body,{name:s,type:n,size:o}=r,a={};try{const t=this.userFromRequest(e),{fileServer:c}=this;i.assertTrue(c,"fileServer");const d=P.default.extname(s).slice(1).toLowerCase();let u=n.split("/").pop();if(u&&!i.isLoadType(u)&&(u=""),u||=c.extensionLoadType(d),u)if(c.withinLimits(o,u)){const e=u;a.loadType=e;const i=Z(),n=c.userUploadPrefix(i,t),o=P.default.join(n,`original.${d}`),h=me(e,o,i,s);await this.directoryPromise(t,h),a.id=i,a.fileProperty=c.property,a.fileApiCallback=c.constructCallback(r,t,i),a.apiCallback=this.startCallback(h)}else a.error=i.Errors.invalid.size;else a.error=i.Errors.invalid.type}catch(e){a.error=String(e)}t.send(a)}}class ve{constructor(e,t,i,r="stream"){this.id=t,this.type=r;try{x.default.mkdirSync(this.socketDir,{recursive:!0}),x.default.statSync(this.socketDir),x.default.statSync(this.socketPath),x.default.unlinkSync(this.socketPath)}catch(e){}const s=I.default.createServer(i);e.on("finish",(()=>{s.close()})),e.on("error",(e=>{console.error(this.constructor.name,"error",e),s.close()})),s.listen(this.socketPath)}id;get socketDir(){return P.default.resolve("./temporary/streams/Sockets",this.type)}get socketPath(){return`${this.socketDir}/${this.id}.sock`}type;get url(){return`unix:${this.socketPath}`}}const be=(e,t,i="input")=>new ve(e,t,(t=>{e.pipe(t)}),i),Pe=require("wrtc"),{RTCPeerConnection:xe}=Pe,{RTCAudioSink:De,RTCVideoSink:we}=Pe.nonstandard;class Ee extends T.default{constructor(e,t,i){super(),this.id=e,this.state="open",i&&(this.commandOutput=i),t&&(this.outputPrefix=t),this.onIceConnectionStateChange=this.onIceConnectionStateChange.bind(this),this.onAudioData=this.onAudioData.bind(this),this.onFrameData=this.onFrameData.bind(this),this.beforeOffer()}async applyAnswer(e){await this.peerConnection.setRemoteDescription(e)}beforeOffer(){const e=this.createAudioSink(),t=this.createVideoSink();t.addEventListener("frame",this.onFrameData),e.addEventListener("data",this.onAudioData);const{close:i}=this.peerConnection,{stream:r}=this;r?.audio.on("end",(()=>{e.removeEventListener("data",this.onAudioData)})),this.peerConnection.close=function(){if(e.stop(),t.stop(),!r)return;const{audio:s,video:n,end:o}=r;return o?void 0:(s&&s.end(),n.end(),i.apply(this))}}createAudioSink(){const e=this.peerConnection.addTransceiver("audio");return new De(e.receiver.track)}createVideoSink(){const e=this.peerConnection.addTransceiver("video");return new we(e.receiver.track)}close(){this.peerConnection.removeEventListener("iceconnectionstatechange",this.onIceConnectionStateChange),this.connectionTimer&&(clearTimeout(this.connectionTimer),this.connectionTimer=void 0),this.reconnectionTimer&&(clearTimeout(this.reconnectionTimer),this.reconnectionTimer=void 0),this.peerConnection.close(),this.state="closed",this.emit("closed")}connectionTimer=setTimeout((()=>{"connected"!==this.peerConnection.iceConnectionState&&"completed"!==this.peerConnection.iceConnectionState&&this.close()}),1e4);async doOffer(){const e=await this.peerConnection.createOffer();await this.peerConnection.setLocalDescription(e);try{await this.waitUntilIceGatheringStateComplete()}catch(e){throw this.close(),e}}get iceConnectionState(){return this.peerConnection.iceConnectionState}id;inputAudio(e){return{source:be(e,this.id,"audio").url,options:{f:"s16le",ar:"48k",ac:1}}}inputVideo(e,t){const{width:i,height:r}=t;return{source:be(e,this.id,"video").url,options:{f:"rawvideo",pix_fmt:"yuv420p",s:`${i}x${r}`,r:"30"}}}get localDescription(){const e=this.peerConnection.localDescription;if(!e)return e;const{sdp:t,...i}=e;return{...i,sdp:t.replace(/\r\na=ice-options:trickle/g,"")}}onAudioData({samples:{buffer:e}}){this.stream&&!this.stream.end&&this.stream.audio.push(Buffer.from(e))}onFrameData(e){const{frame:{width:t,height:i,data:r}}=e,s=this.streamForSize({width:t,height:i});this.streams.forEach((e=>{e===s||e.end||(e.end=!0,e.audio&&e.audio.end(),e.video.end())})),s.video.push(Buffer.from(r))}onIceConnectionStateChange(){["connected","completed"].includes(this.peerConnection.iceConnectionState)?(this.connectionTimer&&(clearTimeout(this.connectionTimer),this.connectionTimer=void 0),this.reconnectionTimer&&(clearTimeout(this.reconnectionTimer),this.reconnectionTimer=void 0)):"disconnected"!==this.peerConnection.iceConnectionState&&"failed"!==this.peerConnection.iceConnectionState||this.connectionTimer||this.reconnectionTimer||(this.reconnectionTimer=setTimeout((()=>{this.close()}),1e4))}commandOutput=i.outputDefaultHls();outputPrefix="./temporary/streams/webrtc";_peerConnection;get peerConnection(){if(this._peerConnection)return this._peerConnection;const e=new xe({sdpSemantics:"unified-plan"});return e.addEventListener("iceconnectionstatechange",this.onIceConnectionStateChange),this._peerConnection=e,e}reconnectionTimer;get remoteDescription(){return this.peerConnection.remoteDescription}get signalingState(){return this.peerConnection.signalingState}state;get stream(){return this.streams[0]}streamForSize(e){const{width:t,height:r}=e,s=this.stream;if(s&&i.sizesEqual(s.size,e))return s;console.log("streamForSize",t,r);const n=P.default.resolve(this.outputPrefix,this.id);x.default.mkdirSync(n,{recursive:!0});const o=new g.PassThrough,a=new g.PassThrough;let c="";const{commandOutput:d}=this,u=String(this.streams.length).padStart(4,"0");switch(d.format){case i.OutputFormat.Hls:{c=`${n}/${u}-${e}.m3u8`;const{options:t}=d;t&&!Array.isArray(t)&&(t.hls_segment_filename=`${n}/${e}-%06d.ts`);break}case i.OutputFormat.Flv:c=`${n}/${u}-${e}.flv`;break;case i.OutputFormat.Rtmp:c="rtmps://..."}console.log("streamForSize commandOutput",d);const h={destination:c,size:e,video:o,audio:a,command:ce(this.id,{inputs:[this.inputVideo(o,e),this.inputAudio(a)],commandFilters:[],output:d,avType:i.AVType.Both})};return this.streams.unshift(h),h.command.run(c),h}streams=[];toJSON(){return{id:this.id,state:this.state,iceConnectionState:this.iceConnectionState,localDescription:this.localDescription,remoteDescription:this.remoteDescription,signalingState:this.signalingState}}async waitUntilIceGatheringStateComplete(){if("complete"===this.peerConnection.iceGatheringState)return;const e=new Promise(((e,t)=>{const i=t=>{t.candidate||(clearTimeout(r),this.peerConnection.removeEventListener("icecandidate",i),e())},r=setTimeout((()=>{this.peerConnection.removeEventListener("icecandidate",i),t(new Error(`Timed out waiting for host candidates ${this.peerConnection}`))}),2e3);this.peerConnection.addEventListener("icecandidate",i)}));await e}static close(){this.getConnections().forEach((e=>{this.deleteConnection(e)}))}static connectionsById=new Map;static callbacksByConnection=new Map;static create(e,t,i){const r=new Ee(e,t,i),s=()=>{this.deleteConnection(r)};return this.callbacksByConnection.set(r,s),r.once("closed",s),this.connectionsById.set(r.id,r),r}static deleteConnection(e){this.connectionsById.delete(e.id);const t=this.callbacksByConnection.get(e);t&&(this.callbacksByConnection.delete(e),e.removeListener("closed",t))}static getConnection(e){return this.connectionsById.get(e)||null}static getConnections(){return[...this.connectionsById.values()]}static toJSON(){return this.getConnections().map((e=>e.toJSON()))}}const Ce=(e,t)=>{if(!x.default.existsSync(e))return;const i=x.default.readdirSync(e).filter((e=>e.endsWith(t))).sort(),r=i.length,s=r&&i[r-1];return s?`${e}/${s}`:void 0},Te={latest:Ce};class Oe extends T.default{constructor(e){super(),this.args=e;const{id:t}=e;this.id=t,this.state="open"}args;close(){this.state="closed",this.emit("closed")}command;cut(e){const{cacheDirectory:t,filePrefix:r,defaultDirectory:s,validDirectories:n,temporaryDirectory:o}=this.args,{mashObjects:a,definitionObjects:c}=e,d=new de(o,t,r,s,n),u=a.map((e=>i.mashInstance({...e,definitionObjects:c,preloader:d}))),h={commandOutput:{...this.args.commandOutput,options:this.currentOptions},cacheDirectory:t,mashes:u},p=new i.VideoStreamOutputClass(h),l=p.args.commandOutput.videoRate,{pathPrefix:m,destination:f}=this;x.default.mkdirSync(m,{recursive:!0});try{this.command&&ae(this.command.id),p.streamingDescription().then((e=>{const{commandOutput:t,inputs:r}=e;if(!r?.length){const t={source:"./img/c.png",options:{r:l,loop:1}};e.inputs=[t]}e.inputs?.forEach((e=>{const{source:t}=e;if(!t)throw"no source";if(!i.isString(t))return;if(t.includes("://"))return;const r=`file://${P.default.resolve("../example-express-react",t)}`;if(!x.default.existsSync(t))throw console.error(this.constructor.name,"could not find",t,r),`NOT FOUND ${r}`;e.source=r}));const s={...e,output:t};this.command=ce(Z(),s),this.command.addListener("error",this.error.bind(this)),this.command.run(f)}))}catch(e){return console.error(this.constructor.name,"update CATCH",e),{error:String(e)}}return{}}defaultContent(){const e="../shared/image/favicon.ico",t="image";return{mashObjects:[{tracks:[{clips:[{contentId:t,width:.2}]}]}],definitionObjects:[{source:e,id:t,type:i.DefinitionType.Image,url:e}]}}get destination(){return`${this.pathPrefix}/${this.args.file}`}error(e){String(e).includes("SIGKILL")||(console.error("StreamingProcessClass","errorCallback",e),this.cut(this.defaultContent()))}id;get currentOptions(){const{options:e,format:t}=this.args.commandOutput;if(t!==i.OutputFormat.Hls)return e;const{id:r,pathPrefix:s}=this;if(Ce(s,i.ExtHls)){e.hls_flags||="",e.hls_flags+=(e.hls_flags?"+":"")+"append_list";const t=this.latestTsNumber;i.isNumber(t)&&(e.start_number=t+1)}const{hls_segment_filename:n}=e;return i.isString(n)&&(n.includes("/")||(e.hls_segment_filename=`${s}/${n}`)),e}get latestTsNumber(){const e=Ce(this.pathPrefix,i.ExtTs);if(e)return Number(P.default.basename(e,`.${i.ExtTs}`))}get pathPrefix(){return P.default.resolve(this.args.directory,this.id)}state;toJSON(){return{id:this.id,state:this.state}}}const Fe=new Map,$e=new Map,Ie=()=>{[...Fe.values()].forEach((e=>{je(e)}))},Re=e=>{const t=new Oe(e),i=()=>{je(t)};return $e.set(t,i),t.once("closed",i),Fe.set(t.id,t),t},je=e=>{Fe.delete(e.id);const t=$e.get(e);t&&($e.delete(e),e.removeListener("closed",t))},ke=e=>Fe.get(e)||null,Ae={deleteAll:Ie,delete:je,get:ke,create:Re},Le=require("node-media-server");class Me extends B{args;constructor(e){super(e),this.args=e}cut=(e,t)=>{const r=e.body,{id:s,mashObjects:n,definitionObjects:o}=r,a=ke(s);if(a)try{console.log(i.Endpoints.streaming.cut,"request",r);const e={definitionObjects:o,mashObjects:n},s=a.cut(e);t.send(s)}catch(e){t.send({error:String(e)}),console.error(e)}else t.send({error:"stream not found"})};delete=(e,t)=>{const{id:i}=e.body,r=Ee.getConnection(i);if(!r)return void t.send({error:`no connection ${i}`});r.close();t.send({})};fileServer;local=(e,t)=>{const{id:i}=e.body,r=Ee.getConnection(i);if(!r)return void t.send({error:`no connection ${i}`});const{localDescription:s}=r;if(!s)return t.send({error:`no localDescription for connection ${i}`});const n=r.toJSON().localDescription;if(!n)return t.send({error:`no local description for connection ${i}`});const o={localDescription:n};t.send(o)};remote=async(e,t)=>{const r=e.body;console.log(i.Endpoints.streaming.remote,"request",r);const{id:s,localDescription:n}=r,o=Ee.getConnection(s);if(o)try{await o.applyAnswer(n);const{remoteDescription:e}=o;if(!e)return t.send({error:`no remoteDescription for connection ${s}`});const i=o.toJSON().remoteDescription;if(!i)return t.send({error:`no remote description for connection ${s}`});const r={localDescription:i};t.send(r)}catch(e){t.send({error:String(e)}),console.error(e)}else t.send({error:`no connection ${s}`})};id="streaming";preload=(e,t)=>{e.body;t.send({})};start=(e,t)=>{const r=e.body;console.log(i.Endpoints.streaming.start,"request",r);const{width:s,height:n,videoRate:o,format:a}=r,c=a||i.StreamingFormat.Hls,d=Z(),u=this.args.streamingFormatOptions[c],{commandOutput:h,directory:p,file:l}=u,m={...h};s&&(m.width=s),n&&(m.height=n),o&&(m.videoRate=o);const f=i.outputDefaultStreaming(m),{width:g,height:y,videoRate:S,options:v}=f,b={width:g,height:y,videoRate:S,format:c,id:d,readySeconds:10};if(c===i.StreamingFormat.Hls){const{hls_time:e}=v;i.isPositive(e)&&(b.readySeconds=e)}try{const t=this.userFromRequest(e),{cacheDirectory:i,temporaryDirectory:r}=this.args,s=this.fileServer.args.uploadsPrefix,n=Re({filePrefix:s,defaultDirectory:t,validDirectories:["shared"],cacheDirectory:i,id:d,directory:p,file:l,commandOutput:f,temporaryDirectory:r});n.cut(n.defaultContent())}catch(e){b.error=String(e)}t.send(b)};startMediaServer(){this.args.appName;const{videoCodec:e,width:t,height:r,audioCodec:s,audioBitrate:n,audioChannels:o,audioRate:a,format:c}=this.args.streamingFormatOptions[i.StreamingFormat.Hls].commandOutput;i.OutputFormat.Hls;const d={http:this.args.httpOptions};new Le(d).run()}startServer(e,t){super.startServer(e,t),this.fileServer=t.file,e.post(i.Endpoints.streaming.start,this.start),e.post(i.Endpoints.streaming.preload,this.preload),e.post(i.Endpoints.streaming.status,this.status),e.post(i.Endpoints.streaming.cut,this.cut),e.post(i.Endpoints.streaming.local,this.local),e.post(i.Endpoints.streaming.remote,this.remote),e.post(i.Endpoints.streaming.webrtc,this.webrtc),e.post(i.Endpoints.streaming.delete,this.delete),e.get("/webrtc/:id",((e,t)=>{const{id:i}=e.params,r=Ee.getConnection(i);r?t.send(r):t.send({error:`no connection ${i}`})})),e.get(`/hls/:id/*.${i.ExtTs}`,(async(e,t)=>{const i=this.args.streamingFormatOptions.hls,{params:r,path:s}=e,n=P.default.basename(s),{id:o}=r,a=`${i.directory}/${o}/${n}`;try{t.send(x.default.readFileSync(a))}catch(e){t.sendStatus(500)}})),e.get(`/hls/:id/*.${i.ExtHls}`,(async(e,t)=>{const{id:r}=e.params,s=this.args.streamingFormatOptions.hls;try{const e=Ce(P.default.join(s.directory,r),i.ExtHls);if(!e)return console.error(`404 /hls/:id/*.${i.ExtHls}`,r),void t.sendStatus(404);t.send(x.default.readFileSync(e))}catch(e){console.error(e),t.sendStatus(500)}})),this.startMediaServer()}status=(e,t)=>{const{body:i}=e,{id:r}=i,s={},n=ke(r);if(n){const{format:e}=n.args.commandOutput,t=e;this.streamReady(r,t)&&(s.streamUrl=this.streamUrl(r,t))}else s.error="stream not found";t.send(s)};stopServer(){Ee.close()}streamReady(e,t){const r=this.args.streamingFormatOptions[t],s=[];switch(t){case i.StreamingFormat.Hls:s.push(P.default.resolve(r.directory,e,r.segmentFile)),s.push(P.default.resolve(r.directory,e,r.file));break;case i.StreamingFormat.Rtmp:default:s.push(P.default.resolve(r.directory,e,r.file))}return!!s.length&&s.every((e=>x.default.existsSync(e)))}streamUrl(e,t){const i=this.args.streamingFormatOptions[t],{url:r,file:s}=i;return`${r}/${e}/${s}`}webrtc=async(e,t)=>{try{const r=e.body;console.log(i.Endpoints.streaming.webrtc,"request",r);const s=this.args.streamingFormatOptions[i.StreamingFormat.Hls],n=Ee.create(Z(),this.args.webrtcStreamingDir,s.commandOutput);await n.doOffer();const{localDescription:o,id:a}=n;if(!o)return void t.send({error:"could not create connection"});const c={localDescription:o,id:a};t.send(c)}catch(e){t.send({error:String(e)}),console.error(e)}}}class _e extends B{args;constructor(e){super(e),this.args=e}startServer(e,t){super.startServer(e,t),Object.entries(this.args.sources).forEach((([t,i])=>{const r=P.default.resolve(i),s=x.default.existsSync(r),n=s&&x.default.lstatSync(r).isDirectory();if(!s)throw`${this.constructor.name}.startServer ${r}`;const o=n?"index.html":P.default.basename(r),a=n?r:P.default.dirname(r);e.use(t,v.default.static(a,{index:o})),console.debug(this.constructor.name,"serving",t,"from",a,"with",o,"index")}))}}exports.ApiServerClass=J,exports.Authenticator=(t,i,r)=>{t.httpVersion?r():(console.warn("Authenticator blocked"),e.response.statusCode=401,i.end(""))},exports.BasenameCache="cached",exports.BasenameDefinition="definition",exports.BasenameRendering="rendering",exports.DataServerClass=ie,exports.Directory=Te,exports.ExtensionCommands="commands.txt",exports.ExtensionLoadedInfo="info.txt",exports.FileServerClass=re,exports.FileServerFilename="original",exports.Host=class{constructor(e){this.args=e}args;start(){const{corsOptions:e,host:t,port:r,api:s,file:n,data:o,rendering:a,streaming:c,web:d}=this.args,u={};s&&(u[i.ServerType.Api]=new J(s)),o&&(u[i.ServerType.Data]=new ie(o)),n&&(u[i.ServerType.File]=new re(n)),a&&(u[i.ServerType.Rendering]=new Se(a)),c&&(u[i.ServerType.Streaming]=new Me(c)),d&&(u[i.ServerType.Web]=new _e(d));const h=Object.values(u);if(!h.length)return void console.warn(this.constructor.name,"nothing configured");const p=v.default();p.use(v.default.json()),e&&p.use(D.default(e)),h.forEach((e=>{e.startServer(p,u)}));p.listen(r,t,(()=>{console.log(`Listening on port ${r}`)})).once("close",(()=>{h.forEach((e=>e.stopServer()))}))}},exports.HostDefaultOptions=(e={})=>{const{previewSize:t,outputSize:r,outputRate:s,port:n,auth:o,webServerHome:a,temporaryDirectory:c,fileUploadDirectory:d,dataMigrationsDirectory:u,dataBaseFile:h,renderingCacheDirectory:p,host:l,version:m,renderingCommandOutputs:f}=e,g=l||"0.0.0.0",y={},S=n||8570;if(r){const{width:e,height:t}=r;y.width=e,y.height=t}s&&(y.videoRate=s);const v=c||"./temporary",b=p||`${v}/cache`,x=u||"./workspaces/example-express-react/host/data-migrations",D=a||"./workspaces/example-express-react/host/public/index.html",w=P.default.dirname(D),E=h||`${P.default.dirname(x)}/sqlite.db`,C=d||`${w}/media`,T=f||{};if(!C.startsWith(w))throw"fileUploadDirectory must be under webServerHome";const O=P.default.relative(w,C),F=o||V;"basic"===F.type&&(F.password=z(F.password));return{port:S,host:g,version:m,corsOptions:{origin:"*"},api:{authentication:F},data:{temporaryIdPrefix:"temporary-",dbPath:E,dbMigrationsPrefix:x,authentication:F},file:{uploadLimits:{video:100,audio:50,image:5},uploadsPrefix:C,uploadsRelative:O,extensions:{[i.LoadType.Audio]:["aiff","mp3"],[i.LoadType.Image]:["jpeg","jpg","png","svg"],[i.LoadType.Video]:["mov","mp4","mpeg","mpg"]},authentication:F},rendering:{temporaryDirectory:v,cacheDirectory:b,authentication:F,commandOutputs:T,previewSize:t,outputSize:r},streaming:{streamingFormatOptions:{[i.StreamingFormat.Hls]:{commandOutput:i.outputDefaultHls(y),segmentFile:`000000.${i.ExtTs}`,url:"/hls",directory:`${v}/streams`,file:`index.${i.ExtHls}`},[i.StreamingFormat.Rtmp]:{commandOutput:i.outputDefaultRtmp(y),segmentFile:"",file:`index.${i.ExtRtmp}`,url:"/rtmp",directory:`${v}/streams/rtmp`},[i.StreamingFormat.Mdash]:{commandOutput:i.outputDefaultDash(y),segmentFile:"",file:`index.${i.ExtDash}`,url:"/rtmp",directory:`${v}/streams/mdash`}},commandOutput:i.outputDefaultHls(y),appName:i.StreamingFormat.Rtmp,cacheDirectory:`${v}/cache`,temporaryDirectory:v,webrtcStreamingDir:`${v}/streams/webrtc`,rtmpOptions:{port:1935,chunk_size:6e4,gop_cache:!0,ping:30,ping_timeout:60},httpOptions:{port:S+1,mediaroot:`${v}/streams`,allow_origin:"*"},authentication:F},web:{sources:{"/":D},authentication:F}}},exports.HostDefaultPort=8570,exports.NodeLoader=de,exports.Probe=W,exports.RenderingProcessClass=ge,exports.RenderingServerClass=Se,exports.RunningCommandClass=se,exports.ServerClass=B,exports.StreamInput=be,exports.StreamOutput=(e,t,i="output")=>new ve(e,t,(t=>{t.pipe(e)}),i),exports.StreamUnix=ve,exports.StreamingProcessClass=Oe,exports.StreamingProcessFactory=Ae,exports.StreamingServerClass=Me,exports.WebServerClass=_e,exports.WebrtcConnection=Ee,exports.commandArgsString=q,exports.commandErrors=_,exports.commandExpandComplex=L,exports.commandInstance=k,exports.commandPath=(e="ffmpeg")=>{b.default.setFfmpegPath(e)},exports.commandProcess=j,exports.commandQuoteComplex=M,exports.definitionTypeFromRaw=fe,exports.directoryLatest=Ce,exports.expandCommand=N,exports.expandFile=H,exports.expandFileOrScript=z,exports.expandPath=e=>e.startsWith(".")?P.default.resolve(e):e,exports.expandToJson=U,exports.idUnique=Z,exports.renderingClipFromDefinition=le,exports.renderingCommandOutputs=he,exports.renderingDefinitionObject=me,exports.renderingInput=ue,exports.renderingInputFromRaw=(e,t,i={})=>{const r=i.id||t,s=me(e,t,String(r),String(i.label));return ue(s,i)},exports.renderingOutputFile=pe,exports.renderingProcessInstance=ye,exports.renderingSource=e=>{if(!e)return"";const{format:t,extension:r,outputType:s}=e,n=r||t;return s===i.OutputType.ImageSequence?"":`${s}.${n}`},exports.runningCommandDelete=ae,exports.runningCommandGet=oe,exports.runningCommandInstance=ce,exports.streamingProcessCreate=Re,exports.streamingProcessDelete=je,exports.streamingProcessDeleteAll=Ie,exports.streamingProcessGet=ke;
