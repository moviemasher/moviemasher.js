{"version":3,"file":"static/js/94.e67b6f9d.chunk.js","mappings":"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","sources":["../node_modules/@moviemasher/client-core/src/Config/Config.ts","../node_modules/@moviemasher/client-core/src/Client/Client.ts","../node_modules/@moviemasher/client-core/src/Client/ClientClass.ts","../node_modules/@moviemasher/client-core/src/Client/ClientFactory.ts","../node_modules/@moviemasher/client-core/src/Utility/Audio.ts","../node_modules/@moviemasher/client-core/src/Utility/Json.ts","../node_modules/@moviemasher/client-core/src/Utility/Image.ts","../node_modules/@moviemasher/client-core/src/Utility/Video.ts","../node_modules/@moviemasher/client-core/src/Protocol/Http.ts","../node_modules/@moviemasher/client-core/src/Protocol/Blob.ts","../node_modules/@moviemasher/client-core/src/Utility/DragDrop.ts","../node_modules/@moviemasher/client-core/src/Utility/Pixel.ts","../node_modules/@moviemasher/client-core/src/Utility/Activity.ts"],"sourcesContent":["import { isPopulatedString, isString, ValueRecord, Value, isNumber } from \"@moviemasher/moviemasher.js\"\n\nexport enum Config {\n  SUPABASE_PROJECT_URL = 'MOVIEMASHER_SUPABASE_PROJECT_URL',\n  SUPABASE_ANON_KEY = 'MOVIEMASHER_SUPABASE_ANON_KEY',\n  SUPABASE_BUCKET = 'MOVIEMASHER_SUPABASE_BUCKET',\n  SUPABASE_EXPIRES = 'MOVIEMASHER_SUPABASE_EXPIRES',\n  SUPABASE_TABLE = 'MOVIEMASHER_SUPABASE_TABLE',\n}\n\nconst ConfigDefaults: ValueRecord = {\n  [Config.SUPABASE_PROJECT_URL]: '',\n  [Config.SUPABASE_BUCKET]: 'media',\n  [Config.SUPABASE_TABLE]: 'media',\n  [Config.SUPABASE_ANON_KEY]: '',\n  [Config.SUPABASE_EXPIRES]: 60,\n}\n\nexport const config = (key: Config, value?: Value): Value => {\n  if (isString(value) || isNumber(value)) ConfigDefaults[key] = value\n  return ConfigDefaults[key] || ''\n}","import { \n  AlphaProbe, AudibleProbe, AudioType, CookedTypes, DecodeOutput, Decoding, \n  DurationProbe, Encoding, Endpoints, ImageType, LoadType, MashMedia, MashType, \n  Media, MediaType, MediaTypes, OrderDecending, PotentialError, ProbeType, \n  RawTypes, Request, SizeProbe, StringRecord, Strings, TranscodeOutput, \n  Transcoding, VideoType \n} from \"@moviemasher/moviemasher.js\"\n\nexport interface DecodeTypesByMediaType extends Record<LoadType, DecodeOutput[]> {}\nexport interface TranscodingTypesByMediaType extends Record<LoadType, TranscodeOutput[]> {}\n\n\nexport type ReadOperation = 'read'\nexport type WriteOperation = 'write'\nexport type TranscodeOperation = 'transcode'\nexport type EncodeOperation = 'encode'\nexport type DecodeOperation = 'decode'\nexport const ReadOperation: ReadOperation = 'read'\nexport const WriteOperation: WriteOperation = 'write'\nexport const TranscodeOperation: TranscodeOperation = 'transcode'\nexport const EncodeOperation: EncodeOperation = 'encode'\nexport const DecodeOperation: DecodeOperation = 'decode'\n\nexport type Operation = ReadOperation | WriteOperation | TranscodeOperation | EncodeOperation | DecodeOperation\nexport type Operations = Operation[]\nexport const Operations: Operations = [ReadOperation, WriteOperation, TranscodeOperation, EncodeOperation, DecodeOperation]\nexport const isOperation = (value: any): value is Operation => {\n  return Operations.includes(value)\n}\n\n\nexport interface Client {\n  accept(options?: ClientSaveOptions): string | undefined\n  enabled(operation?: Operation): boolean\n  decode(options: ClientDecodeOptions): Promise<Decoding>\n  encode(mashMedia: MashMedia, options?: ClientEncodeOptions): Promise<Encoding>\n  list(options?: ClientReadOptions): Promise<ClientArrayResponse>\n  get(options?: ClientReadOptions): Promise<ClientObjectResponse>\n\n  save(media: Media, options?: ClientSaveOptions): Promise<ClientObjectResponse>\n  transcode(options: ClientTranscodeOptions): Promise<Transcoding>\n}\n\n\nexport interface ClientDecodeOptions { \n  autoDecode?: DecodeTypesByMediaType | false\n}\n\nexport interface ClientEncodeOptions {\n  autoTranscode?: TranscodingTypesByMediaType | false\n}\n\nexport interface ClientTranscodeOptions {\n  autoTranscode?: TranscodingTypesByMediaType | false\n}\nexport interface ClientReadParams {\n  type?: MediaType | MediaTypes\n  kind?: string | Strings\n  order?: string | StringRecord\n}\nexport interface ClientReadOptions extends ClientReadParams {\n  autoGet?: ClientReadParams | false\n  getRequest?: Request | false\n  listRequest?: Request | false\n}\n\nexport interface ClientArgs extends Required<ClientOptions> {}\n\nexport interface ClientWriteOptions {\n  accept?: string | Strings \n  saveRequest?: Request | false\n  deleteRequest?: Request | false\n  uploadRequest?: Request | false\n  uploadResponseIsRequest?: boolean\n  uploadCookedTypes?: CookedTypes\n}\n\nexport interface ClientOptions {\n  [ReadOperation]?: ClientReadOptions | false | undefined\n  [WriteOperation]?: ClientWriteOptions | false | undefined\n  [DecodeOperation]?: ClientDecodeOptions | false | undefined\n  [EncodeOperation]?: ClientEncodeOptions | false | undefined\n  [TranscodeOperation]?: ClientTranscodeOptions | false | undefined\n} \n\n\nexport const ClientDisabledArgs: ClientArgs = {\n  [ReadOperation]: false,\n  [WriteOperation]: false,\n  [DecodeOperation]: false,\n  [EncodeOperation]: false,\n  [TranscodeOperation]: false,\n}\n\nexport const ClientDefaultArgs: ClientArgs = {\n  [DecodeOperation]: {\n    autoDecode: {\n      [AudioType]: [{ \n        type: ProbeType, \n        options: { types: [DurationProbe] }\n      }],\n      [ImageType]: [{ \n        type: ProbeType, \n        options: { types: [AlphaProbe, SizeProbe] }\n      }],\n\n      [VideoType]: [{ \n        type: ProbeType, \n        options: { \n          types: [\n            DurationProbe, SizeProbe, \n            AlphaProbe, AudibleProbe \n          ] \n        }\n      }],\n    },\n  },\n  [EncodeOperation]: {\n\n  },\n  [ReadOperation]: {\n    autoGet: { type: MashType, order: { created_at: OrderDecending }},\n    getRequest: { endpoint: { pathname: Endpoints.data.definition.get } }, \n    listRequest: { endpoint: { pathname: Endpoints.data.definition.retrieve } },\n      \n  },\n  [TranscodeOperation]: {\n    autoTranscode: {\n      [AudioType]: [\n        { \n          type: AudioType, \n          options: { outputType: AudioType } \n        }\n      ],\n    },\n  },\n  [WriteOperation]: {\n    accept: RawTypes.map(type => `${type}/*`),\n    saveRequest: { endpoint: { pathname: Endpoints.data.definition.put} }, \n    deleteRequest: { endpoint: { pathname: Endpoints.data.definition.delete } }, \n    uploadRequest: { endpoint: { pathname: Endpoints.data.definition.retrieve } },\n    uploadResponseIsRequest: true,\n    uploadCookedTypes: [],\n  },\n}\n\nexport interface ClientSaveOptions extends ClientOptions {\n  callback?: ClientCallback\n}\n\nexport interface ClientProgress extends PotentialError {\n  mash?: MashMedia\n  media: Media\n  processing?: Transcoding | Encoding | Decoding\n  completed: number\n}\n\nexport interface ClientProgessSteps extends ClientProgress {\n  steps: number\n  step: number\n}\n\nexport type ClientCallback = (progress: ClientProgress) => void\n\n\nexport interface ClientArrayResponse extends PotentialError {\n  data?: Media[]\n}\nexport interface ClientObjectResponse extends PotentialError {\n  data?: Media\n}\n\nexport type ClientSaveResponse = ClientArrayResponse | ClientObjectResponse\n\n\n\n","import { \n  assertIdentified, DataDefinitionPutRequest, DataDefinitionPutResponse, \n  Decoding, Encoding, isMashMedia, MashMedia, Media, MediaObject, MediaArray, \n  requestRecordPromise, Transcoding, transcodingInstance, VideoType, \n  Request, ErrorName, error, idIsTemporary, assertPopulatedString, isMedia, \n  isVideoMedia, isImageMedia, isUpdatableDurationDefinition, \n  PotentialError, ProbeType, isArray, \n} from \"@moviemasher/moviemasher.js\"\n\nimport { \n  Client, ClientOptions, ClientDecodeOptions, ClientEncodeOptions, \n  ClientReadOptions, ClientSaveOptions, ClientTranscodeOptions, \n  ClientObjectResponse, ClientProgessSteps, ClientArrayResponse, \n  ClientDefaultArgs, ClientArgs, Operation, isOperation, Operations, WriteOperation} from \"./Client\"\n\n\nexport class ClientClass implements Client {\n  constructor(public options?: ClientOptions) {}\n\n  accept(options?: ClientSaveOptions): string | undefined { \n    const args = this.clientArgs(options)\n    const { write } = args\n    if (!write) return \n\n    const { accept } = write\n    return isArray(accept) ? accept.join(',') : accept\n  }\n\n\n  enabled(operation?: Operation): boolean {\n    const operations = isOperation(operation) ? [operation] : Operations\n    return operations.every(operation => {\n\n    })\n  }\n\n  get(options?: ClientReadOptions | undefined): Promise<ClientObjectResponse> {\n       throw new Error(\"Method not implemented.\")\n \n  }\n  list(args: ClientReadOptions): Promise<ClientArrayResponse> {\n    throw new Error(\"Method not implemented.\")\n  }\n  save(media: Media, options?: ClientSaveOptions): Promise<ClientObjectResponse> {\n    const args = this.clientArgs(options)\n\n    if (isMashMedia(media)) return this.saveMash(media, args) \n    \n    const steps: ClientProgessSteps = {\n      step: 0, steps: 2, media, completed: 0\n    }\n    this.saveMedia(media, steps, args)\n    \n    const response: ClientObjectResponse = {}\n    return Promise.resolve(response)\n  }\n\n  private clientArgs(clientOptions: ClientOptions = {}): ClientArgs {\n    const { options = {}} = this\n    return { ...ClientDefaultArgs, ...options, ...clientOptions }\n  }\n  \n  protected saveMash(mash: MashMedia, args: ClientArgs): Promise<ClientObjectResponse> {\n    const temporaryIds = mash.definitionIds.filter(idIsTemporary)\n    const temporaryMedia = temporaryIds.map(id => mash.media.fromId(id))\n\n    const steps: ClientProgessSteps = {\n      step: 0, steps: 1, mash, media: mash, completed: 0\n    }\n    \n    return this.saveMedias(temporaryMedia, steps, args).then(result => \n      result.error ? result : this.saveMediaRow(mash, steps, args)\n    )\n  }\n    // const definitionsPromise = saveDefinitionsPromise(definitionsUnsaved)\n    // const requestPromise = definitionsPromise.then(() => editor.dataPutRequest())\n    // const savePromise = requestPromise.then(request => {\n    //   // const { editType } = editor\n    //   console.debug(\"DataPutRequest\", Endpoints.data[editType].put, JSON.parse(JSON.stringify(request)))\n    //   endpointPromise(Endpoints.data[editType].put, request).then((response: DataPutResponse) => {\n    //     console.debug(\"DataPutResponse\", Endpoints.data[editType].put, response)\n    //     const { error, temporaryIdLookup } = response\n    //     if (error) console.error(Endpoints.data[editType].put, error)\n    //     else editor.saved(temporaryIdLookup)\n    //   })\n    // })\n\n\n  // dataPutRequest(): Promise<DataPutRequest> {\n  //   const { mashMedia, editType } = this\n  //   assertObject(mashMedia, 'edited')\n  //   assertEditType(editType)\n\n  //   // set edit's label if it's empty\n  //   const { label } = mashMedia \n  //   if (!isPopulatedString(label)) {\n  //     const defaultLabel = Default[editType].label\n  //     assertPopulatedString(defaultLabel, 'defaultLabel')\n  //     mashMedia.setValue(defaultLabel, 'label')\n  //   }\n  \n  //   return mashMedia.putPromise().then(() => {\n  //     if (isMashMedia(mashMedia)) {\n  //       return {\n  //         mash: mashMedia.toJSON(),\n  //         definitionIds: mashMedia.definitionIds\n  //       }\n  //     } \n  //   })\n  // }\n\n\n  private errorPromise(code: ErrorName = ErrorName.Internal): Promise<PotentialError> {\n    return Promise.resolve(error(code))\n  }\n  protected saveMediaRow(media: Media, steps: ClientProgessSteps, args: ClientArgs): Promise<ClientObjectResponse> {\n    const { id, type } = media\n    const options = args[WriteOperation]\n    if (!options) return this.errorPromise()\n\n    const { saveRequest } = options\n    if (!saveRequest) return this.errorPromise()\n\n\n    const requestObject: Request = { ...saveRequest }\n    requestObject.init ||= {}\n    const definition: MediaObject = { id, ...media.toJSON() }\n    const request: DataDefinitionPutRequest = { definition }\n    requestObject.init.body = request\n    return requestRecordPromise(requestObject).then(result => {\n      assertIdentified(result)\n      const { id, error } = result as DataDefinitionPutResponse\n      steps.step++\n      const response: ClientObjectResponse = { error, data: media }\n      return response\n    })\n  }\n\n  protected saveAutoDecodings(media: Media, steps: ClientProgessSteps, args: ClientArgs): Promise<ClientObjectResponse> {\n    return Promise.resolve(error(ErrorName.ClientDisabledDelete))\n\n  }\n\n\n  \n  protected upload(media: Media, steps: ClientProgessSteps, args: ClientArgs): Promise<ClientObjectResponse> {\n    return Promise.resolve(error(ErrorName.ClientDisabledDelete))\n    //   const { uploadResponseIsRequest, uploadCookedTypes } = args\n\n  //   if (uploadResponseIsRequest) {\n\n  //   }\n\n  //   const { label, type, clientMedia } = media\n  //   if (!clientMedia) return Promise.resolve(error(ErrorName.Internal))\n  \n  //   if (isRawType(type)) {\n  //     type\n  //   }\n  //   switch (type) {\n  //     case AudioType:\n  //     case ImageType:\n  //     case VideoType:\n        \n  //       break;\n    \n  //     default:\n  //       break;\n  //   }\n\n\n  //   const id = idGenerate('activity')\n  \n  //   const { rendering } = Endpoints\n  //   console.log(\"Masher fetch\", source)\n  //   const responsePromise = fetch(source)\n  //   const blobPromise = responsePromise.then(response => response.blob())\n  //   const filePromise = blobPromise.then(blob => new File([blob], label))\n  //   const resultPromise = filePromise.then(file => {\n  //     const request: RenderingUploadRequest = { type, name: label, size: file.size }\n  //     console.debug(\"RenderingUploadRequest\", rendering.upload, request)\n  //     const responsePromise = endpointPromise(rendering.upload, request)\n  //     return responsePromise.then((response: RenderingUploadResponse) => {\n  //       console.debug(\"RenderingUploadResponse\", rendering.upload, response)\n  //       const { error, fileApiCallback, apiCallback, fileProperty } = response\n  //       if (error) return handleError(rendering.upload, error, id)\n  \n  //       else if (fileApiCallback && fileApiCallback.init) {\n  //         if (fileProperty) fileApiCallback.init.body![fileProperty] = file\n  //         else fileApiCallback.init.body = file\n  //         return jsonPromise(fileApiCallback).then((response: FileStoreResponse) => {\n  //           console.debug(\"FileStoreResponse\", response)\n  //           const { error } = response\n  //           if (error) return handleError(fileApiCallback.endpoint.pathname!, error, id)\n  \n  //           assertObject(apiCallback, 'apiCallback')\n  //           return handleApiCallback(id, definition, apiCallback)\n  //         })\n  //       } \n  //       assertObject(apiCallback, 'apiCallback')\n  //       return handleApiCallback(id, definition, apiCallback)\n  //     })\n  //  })\n  }\n  protected saveUpload(media: Media, steps: ClientProgessSteps, args: ClientArgs): Promise<ClientObjectResponse> {\n    const { id } = media\n    if (idIsTemporary(id)) return this.upload(media, steps, args)\n\n    return this.saveMediaRow(media, steps, args)\n  }\n\n  protected saveAutoTranscodings(media: Media, steps: ClientProgessSteps, args: ClientArgs): Promise<ClientObjectResponse> {\n    return Promise.resolve(error(ErrorName.ClientDisabledDelete))\n\n  }\n\n  \n  protected saveMedia(media: Media, steps: ClientProgessSteps, args: ClientArgs): Promise<ClientObjectResponse> {\n    return Promise.resolve(error(ErrorName.ClientDisabledDelete))\n\n    // steps.media = media\n    // const { autoDecode, autoTranscode } = args\n\n    // const { id, type, transcodings, decodings } = media\n    // return this.saveUpload(media, steps, args).then(result => (\n    //   result.error ? result : this.saveAutoDecodings(media, steps, args)\n    // ))\n\n    // if (!decodings.length && autoDecode && autoDecode[type])\n\n    // return this.saveMediaRow(media, steps, args)\n\n    \n  }\n\n\n  private updateMedia(mediaObject: MediaObject, mash: MashMedia, media?: Media): Promise<void> {\n    \n    const {id: newId } = mediaObject\n    const id = mediaObject.id || media!.id\n    assertPopulatedString(id)\n\n    const target = media || mash.media.fromId(newId!)\n    const { id: oldId } = target\n    const idChanged = oldId !== id\n    console.log(this.constructor.name, \"updateDefinition\", idChanged, mediaObject)\n    if (idChanged) {\n      mash.media.updateDefinitionId(target.id, id)\n      console.log(this.constructor.name, \"updateDefinition called updateDefinitionId\", target.id, id)\n\n      // TODO - replace assign\n      Object.assign(target, mediaObject)\n      \n      if (isMedia(target)) {\n        delete target.file\n        delete target.request.response \n        if (isVideoMedia(target)) {\n          delete target.loadedVideo \n        }\n        else if (isUpdatableDurationDefinition(target)) delete target.loadedAudio \n        else if (isImageMedia(target)) delete target.loadedImage \n      }    \n    } \n    if (!idChanged) return Promise.resolve()\n    \n    const { tracks } = mash\n    const clips = tracks.flatMap(track => track.clips)\n    clips.forEach(clip => {\n      if (clip.containerId === oldId) clip.setValue(newId, 'containerId')\n      if (clip.contentId === oldId) clip.setValue(newId, 'contentId')\n    })\n    return mash.reload() || Promise.resolve()\n  }\n\n  protected saveMedias(mediaArray: MediaArray, steps: ClientProgessSteps, args: ClientArgs): Promise<ClientObjectResponse> {\n    let promise: Promise<ClientObjectResponse> = Promise.resolve({})\n    mediaArray.forEach(media => {\n      promise = promise.then(result => (\n        result.error ? result : this.saveMedia(media, steps, args)\n      ))\n    })\n\n    return promise\n  }\n\n  decode(args: ClientDecodeOptions): Promise<Decoding> {\n    return Promise.resolve({ type: ProbeType })\n  }\n\n  encode(mashMedia: MashMedia, args: ClientEncodeOptions): Promise<Encoding> {\n    throw new Error(\"Method not implemented.\")\n\n    // const media = editor.definitions.map(object => object.toJSON()) as MediaObjects\n    // const mashObject = mashMedia.toJSON() as MashMediaObject\n    // const mash: MashAndMediaObject = { ...mashObject, media }\n    // const request: RenderingStartRequest = {\n    //   mash,\n    //   output: {outputType: VideoType},\n    // }\n    // console.debug(\"RenderingStartRequest\", Endpoints.rendering.start, request)\n    // endpointPromise(Endpoints.rendering.start, request).then((response: RenderingStartResponse) => {\n    //   console.debug(\"RenderingStartResponse\", Endpoints.rendering.start, response)\n    //   const { apiCallback, error } = response\n    //   if (error) handleError(Endpoints.rendering.start, request, response, error.message)\n    //   else handleApiCallback(apiCallback!, mashMedia)\n    // })\n\n\n  }\n\n  transcode(args: ClientTranscodeOptions): Promise<Transcoding> {\n    const transcodingobject = { type: VideoType, id: '', request: { endpoint: {}}}\n    const transcoding = transcodingInstance(transcodingobject)\n    return Promise.resolve(transcoding)\n\n  }\n}\n\n\n// let promise = Promise.resolve()\n\n// definitions.forEach(definition => {\n//   assertContentDefinition(definition)\n//   const { label, type, source } = definition\n\n//   const id = idGenerate('activity')\n//   eventTarget.emit(EventType.Active, { id, label, type: ActivityType.Render })\n\n//   const { rendering } = Endpoints\n//   console.log(\"Masher fetch\", source)\n//   const responsePromise = fetch(source)\n//   const blobPromise = responsePromise.then(response => response.blob())\n//   const filePromise = blobPromise.then(blob => new File([blob], label))\n//   const resultPromise = filePromise.then(file => {\n//     const request: RenderingUploadRequest = { type, name: label, size: file.size }\n//     console.debug(\"RenderingUploadRequest\", rendering.upload, request)\n//     const responsePromise = endpointPromise(rendering.upload, request)\n//     return responsePromise.then((response: RenderingUploadResponse) => {\n//       console.debug(\"RenderingUploadResponse\", rendering.upload, response)\n//       const { error, fileApiCallback, apiCallback, fileProperty } = response\n//       if (error) return handleError(rendering.upload, error, id)\n\n//       else if (fileApiCallback && fileApiCallback.init) {\n//         if (fileProperty) fileApiCallback.init.body![fileProperty] = file\n//         else fileApiCallback.init.body = file\n//         return jsonPromise(fileApiCallback).then((response: FileStoreResponse) => {\n//           console.debug(\"FileStoreResponse\", response)\n//           const { error } = response\n//           if (error) return handleError(fileApiCallback.endpoint.pathname!, error, id)\n\n//           assertObject(apiCallback, 'apiCallback')\n//           return handleApiCallback(id, definition, apiCallback)\n//         })\n//       } \n//       assertObject(apiCallback, 'apiCallback')\n//       return handleApiCallback(id, definition, apiCallback)\n//     })\n//   })\n//   promise = promise.then(() => resultPromise)\n// })\n\n\n\n// from rendering server class \n\n  // private populateDefinition(user: string, renderingId: string, definition: MediaObject, commandOutputs: RenderingCommandOutputs): void {\n  //   const { fileServer } = this\n  //   assertTrue(fileServer)\n\n  //   const { id, source, type: definitionType } = definition\n  //   assertPopulatedString(id)\n  //   assertMediaType(definitionType)\n  //   assertPopulatedString(source)\n\n  //   const prefix = path.join(fileServer.userUploadPrefix(id, user), renderingId)\n  //   const outputDirectory = this.outputDirectory(user, id)\n  //   const inInfoName = `upload.${ExtensionLoadedInfo}`\n  //   const inInfoPath = path.join(outputDirectory, renderingId, inInfoName)\n  //   const inInfoExists = fs.existsSync(inInfoPath)\n  //   const inInfo: ProbingData = inInfoExists ? expandToJson(inInfoPath) : {}\n  //   const { \n  //     width: inWidth, height: inHeight,\n  //     duration: inDuration, audible: inAudible, label: inLabel\n  //   } = inInfo\n  //   if (isUpdatableDurationType(definitionType) && isAboveZero(inDuration)) {\n  //     definition.duration = inDuration\n  //   }\n  //   if (isUpdatableSizeType(definitionType)) {\n  //     if (isAboveZero(inWidth) && isAboveZero(inHeight)) {\n  //       definition.sourceSize = { width: inWidth, height: inHeight }\n  //     }\n  //   }\n  //   const countByType: NumberRecord = {}\n  //   commandOutputs.forEach(output => {\n  //     const { outputType } = output\n  //     if (!isDefined(countByType[outputType])) countByType[outputType] = -1\n  //     countByType[outputType]++\n  //     const index = countByType[outputType]\n  //     const outInfoName = renderingOutputFile(index, output, ExtensionLoadedInfo)\n  //     const outInfoPath = path.join(outputDirectory, renderingId, outInfoName)\n\n  //     const outInfo: ProbingData = expandToJson(outInfoPath)\n  //     const { \n  //       width: outWidth, height: outHeight, \n  //       duration: outDuration, audible: outAudible, extension\n  //     } = outInfo\n  //     const outputFilename = renderingOutputFile(index, output, extension)\n  //     const outUrl = path.join(prefix, outputFilename)\n  //     // console.log(this.constructor.name, \"populateDefinition\", outInfo, index, outputType, outUrl)\n  //     switch(outputType) {\n  //       // case EncodeType.ImageSequence: {\n  //       //   if (isAboveZero(outWidth) && isAboveZero(outHeight)) {\n  //       //     definition.fps = output.videoRate\n  //       //     definition.previewSize = { width: outWidth, height: outHeight }\n  //       //     definition.url = prefix + '/'\n  //       //   } \n  //       //   break\n  //       // }\n  //       case EncodeType.Audio: {\n  //         const { duration: definitionDuration } = definition\n  //         if (isAboveZero(outDuration) && isAboveZero(definitionDuration)) {\n  //           definition.audio = true\n  //           definition.duration = Math.min(definitionDuration, outDuration)\n  //           const audioInput = definitionType === AudioType\n  //           if (audioInput) definition.url = outUrl\n  //           else definition.audioUrl = outUrl\n  //         }\n  //         break\n  //       }\n  //       case EncodeType.Image: {\n  //         if (isAboveZero(outWidth) && isAboveZero(outHeight)) {\n  //           const outSize = { width: outWidth, height: outHeight }\n  //           const imageInput = definitionType === ImageType\n  //           if (imageInput && !index) {\n  //             definition.previewSize = outSize\n  //             definition.url = outUrl\n  //           } else definition.icon = outUrl\n  //         }\n  //         break\n  //       }\n  //     }\n  //   })\n  //   // console.log(this.constructor.name, \"populateDefinition\", definition)\n  // }\n  // private _renderingCommandOutputs?: UnusedRenderingCommandOutputs\n  // private get renderingCommandOutputs(): UnusedRenderingCommandOutputs {\n  //   if (this._renderingCommandOutputs) return this._renderingCommandOutputs\n\n  //   const { previewSize, outputSize } = this\n  //   const provided = this.args.commandOutputs || {}\n  //   const outputs = Object.fromEntries(EncodeTypes.map(outputType => {\n  //     const base: RenderingCommandOutput = { outputType }\n  //     switch (outputType) {\n  //       case EncodeType.Image: {\n  //         base.width = previewSize.width\n  //         base.height = previewSize.height\n  //         base.cover = true\n  //         break\n  //       }\n  //       case EncodeType.Video: {\n  //         base.width = outputSize.width\n  //         base.height = outputSize.height\n  //         break\n  //       }\n  //     }\n  //     const commandOutput: CommandOutput = provided[outputType] || {}\n  //     const renderingCommandOutput: RenderingCommandOutput = { ...base, ...commandOutput }\n  //     return [outputType, renderingCommandOutput]\n  //   }))\n  //   return this._renderingCommandOutputs = outputs\n  // }\n\n\n  // FROM Masher.tsx\n\n    // const handleApiCallback = (id: string, definition: Media, callback: ApiCallback): Promise<void> => {\n  //   console.debug(\"handleApiCallback request\", callback)\n  //   const { eventTarget } = editor\n  //   return jsonPromise(callback).then((response: ApiCallbackResponse) => {\n  //     console.debug(\"handleApiCallback response\", response)\n  //     const { apiCallback, error } = response\n  //     if (error) return handleError(callback.endpoint.pathname!, error.message, id)\n\n  //     if (apiCallback) {\n  //       const { init, endpoint } = apiCallback\n  //       if (endpoint.pathname === Endpoints.data.definition.put) {\n  //         assertObject(init, 'init')\n\n  //         const { body } = init\n  //         assertObject(body, 'body')\n\n  //         const putRequest: DataDefinitionPutRequest = body\n  //         const { definition: definitionObject } = putRequest\n  //         console.debug(\"handleApiCallback calling updateDefinition\", definitionObject)\n\n  //         editor.updateDefinition(definitionObject, definition)\n  //         console.debug(\"handleApiCallback called updateDefinition\")\n  //       }\n  //       if (callback.endpoint.pathname === Endpoints.rendering.status) {\n  //         const statusResponse: RenderingStatusResponse = response\n  //         let steps = 0\n  //         let step = 0\n  //         EncodeTypes.forEach(type => {\n  //           const state = statusResponse[type]\n  //           if (!state) return\n\n  //           steps += state.total\n  //           step += state.completed\n  //         })\n  //         if (steps) eventTarget.emit(EventType.Active, { \n  //           id, step, steps, type: ActivityType.Render \n  //         })\n  //       }\n        \n  //       return delayPromise().then(() => handleApiCallback(id, definition, apiCallback))\n  //     }\n  //     eventTarget.emit(EventType.Active, { id, type: ActivityType.Complete })\n  //   })\n  // }\n\n//   const handleError = (endpoint: string, error: string, id: string) => {\n//     editor.eventTarget.emit(EventType.Active, { \n//       id, type: ActivityType.Error, error: 'import.render', value: error \n//     })\n//     console.error(endpoint, error)\n//     return Promise.reject(error)\n//   }\n\n//   const saveDefinitionsPromise = (definitions: MediaArray): Promise<void> => {\n//     let promise = Promise.resolve()\n//     const { eventTarget } = editor\n// throw new Error('')\n//     // definitions.forEach(definition => {\n//     //   assertContentDefinition(definition)\n//     //   const { label, type, source } = definition\n\n//     //   const id = idGenerate('activity')\n//     //   eventTarget.emit(EventType.Active, { id, label, type: ActivityType.Render })\n\n//     //   const { rendering } = Endpoints\n//     //   console.log(\"Masher fetch\", source)\n//     //   const responsePromise = fetch(source)\n//     //   const blobPromise = responsePromise.then(response => response.blob())\n//     //   const filePromise = blobPromise.then(blob => new File([blob], label))\n//     //   const resultPromise = filePromise.then(file => {\n//     //     const request: RenderingUploadRequest = { type, name: label, size: file.size }\n//     //     console.debug(\"RenderingUploadRequest\", rendering.upload, request)\n//     //     const responsePromise = endpointPromise(rendering.upload, request)\n//     //     return responsePromise.then((response: RenderingUploadResponse) => {\n//     //       console.debug(\"RenderingUploadResponse\", rendering.upload, response)\n//     //       const { error, fileApiCallback, apiCallback, fileProperty } = response\n//     //       if (error) return handleError(rendering.upload, error, id)\n\n//     //       else if (fileApiCallback && fileApiCallback.init) {\n//     //         if (fileProperty) fileApiCallback.init.body![fileProperty] = file\n//     //         else fileApiCallback.init.body = file\n//     //         return jsonPromise(fileApiCallback).then((response: FileStoreResponse) => {\n//     //           console.debug(\"FileStoreResponse\", response)\n//     //           const { error } = response\n//     //           if (error) return handleError(fileApiCallback.endpoint.pathname!, error, id)\n    \n//     //           assertObject(apiCallback, 'apiCallback')\n//     //           return handleApiCallback(id, definition, apiCallback)\n//     //         })\n//     //       } \n//     //       assertObject(apiCallback, 'apiCallback')\n//     //       return handleApiCallback(id, definition, apiCallback)\n//     //     })\n//     //   })\n//     //   promise = promise.then(() => resultPromise)\n//     // })\n//     return promise\n//   }\n\n","import { ClientOptions } from \"./Client\"\nimport { ClientClass } from \"./ClientClass\"\n\nexport const clientInstance = (args: ClientOptions = {}) => (\n  new ClientClass(args)\n)","import { \n  assertEndpoint,\n  assertPopulatedString, AudibleContextInstance, AudioDataOrError, \n  endpointUrl, errorCaught, Request\n} from \"@moviemasher/moviemasher.js\"\n\nconst blobAudioPromise = (url: string): Promise<ArrayBuffer> => {\n  // console.log(this.constructor.name, \"blobAudioPromise\", url)\n\n  return fetch(url).then(response => response.blob()).then(blob => {\n    return new Promise<ArrayBuffer>((resolve, reject) => {\n      const reader = new FileReader()\n      reader.onload = () => { resolve(reader.result as ArrayBuffer) }\n      reader.onerror = reject\n      reader.readAsArrayBuffer(blob)\n    }) \n  })\n}\n\nexport const audioDataPromise = (request: Request): Promise<AudioDataOrError> => {\n  const { endpoint } = request\n  assertEndpoint(endpoint)\n\n  const url = endpointUrl(endpoint)\n  assertPopulatedString(url, 'url')\n  // console.log(this.constructor.name, \"audioPromise\", isBlob ? 'BLOB' : url)\n  const promise = blobAudioPromise(url) \n  return promise.then(audioBufferPromise)\n}\n\nexport const audioBufferPromise = (audio: ArrayBuffer): Promise<AudioDataOrError> => {\n  return AudibleContextInstance.decode(audio).then(data => ({ data }))\n    .catch(error => errorCaught(error))\n}\n\n","import { Request, isUndefined, urlForEndpoint, assertEndpoint } from \"@moviemasher/moviemasher.js\"\n\nexport interface ResponseObject {\n  json(): Promise<any>\n\n}\nexport const jsonPromise = (request: Request): Promise<any> => {\n  return fetchPromise(request).then(response => response.json())\n}\n\nexport const fetchPromise = (request: Request): Promise<ResponseObject> => {\n  const { endpoint, init = {} } = request\n  assertEndpoint(endpoint)\n  // console.log('jsonPromise', endpoint, init)\n\n  const typeKey = 'Content-Type'\n  const jsonType = 'application/json'\n\n  const formType = 'multipart/form-data'\n\n  init.method ||= 'POST'\n  init.headers ||= {}\n  init.headers[typeKey] ||= jsonType\n  switch (init.headers[typeKey]) {\n    case jsonType: {\n      init.body = JSON.stringify(init.body)\n      break\n    }\n    case formType: {\n      const formData = new FormData()\n      Object.entries(init.body).forEach(([key, value]) => {\n        if (isUndefined(value)) return\n\n        formData.set(key, value instanceof Blob ? value : String(value))\n      })\n\n      init.body = formData\n      delete init.headers[typeKey]\n      break\n    }\n  }\n\n  const url: string = urlForEndpoint(endpoint)\n  return fetch(url, init)\n}\n","import { \n  endpointUrl, Request, ImageData, ImageDataOrError, ErrorName, error, \n  assertEndpoint \n} from \"@moviemasher/moviemasher.js\"\n\nexport const imageDataPromise = (request: Request): Promise<ImageDataOrError> => {\n  const { endpoint } = request\n  assertEndpoint(endpoint)\n\n  const url = endpointUrl(endpoint)\n  const data = new Image()\n  data.src = url\n  return new Promise<ImageDataOrError>(resolve => {\n    data.onerror = () => {\n      resolve(error(ErrorName.Url))\n    }\n    data.onload = () => { \n      const imageData: ImageData = { data }\n      resolve(imageData) \n    }\n  })\n}\n","import { \n  endpointUrl, ErrorName, Request, errorThrow, VideoDataOrError, errorCaught, assertEndpoint,\n} from \"@moviemasher/moviemasher.js\"\n\n\nconst videoFromUrl = (url: string): HTMLVideoElement => {\n  const { document } = globalThis\n  if (!document) errorThrow(ErrorName.Environment) \n\n  const video = document.createElement('video')\n  // video.crossOrigin = 'anonymous'\n  video.src = url\n  return video\n}\n\nexport const videoDataPromise = (request: Request): Promise<VideoDataOrError> => {\n  const { endpoint } = request\n  assertEndpoint(endpoint)\n\n  const url = endpointUrl(endpoint)\n  \n  return new Promise<VideoDataOrError>((resolve) => {\n    const clientVideo = videoFromUrl(url)\n    clientVideo.oncanplay = () => {\n      clientVideo.oncanplay = null\n      clientVideo.onerror = null\n\n      const { videoWidth, clientWidth, videoHeight, clientHeight } = clientVideo\n      const width = videoWidth || clientWidth\n      const height = videoHeight || clientHeight\n      clientVideo.width = width\n      clientVideo.height = height\n\n      // console.log(this.constructor.name, \"videoPromise.oncanplay\", width, height)\n      resolve({ data: clientVideo })\n    }\n    clientVideo.onerror = error => { resolve(errorCaught(error)) }\n    clientVideo.autoplay = false\n    // video.requestVideoFrameCallback(() => {})\n    clientVideo.load()\n  })\n}\n","import { \n  Request, LoadType, ProtocolPromise, Plugins, \n  assertTrue, isPopulatedString, \n  endpointAbsolute, \n  CssContentType, RequestInit, urlFromCss, endpointUrl, ImageType, AudioType, VideoType, FontType, HttpProtocol, HttpsProtocol, errorThrow, FontDataOrError, ProtocolType, assertEndpoint, RecordType, RecordsType, AudioDataOrError\n} from \"@moviemasher/moviemasher.js\"\nimport { audioBufferPromise } from \"../Utility/Audio\"\nimport { jsonPromise } from \"../Utility/Json\"\nimport { imageDataPromise } from \"../Utility/Image\"\nimport { videoDataPromise } from \"../Utility/Video\"\n\nconst arrayBufferPromise = (url: string, init?: RequestInit): Promise<ArrayBuffer> => (\n   fetch(url, init).then(response => response.arrayBuffer())\n)\n\nconst fontFamily = (url: string): string => url.replaceAll(/[^a-z0-9]/gi, '_')\n\nconst fontPromise =  (request: Request): Promise<FontDataOrError> => {\n  const { endpoint, init } = request\n  assertEndpoint(endpoint)\n\n  const url = endpointUrl(endpoint)\n  \n  const bufferPromise = fetch(url, init).then(response => {\n    const type = response.headers.get('content-type') || ''\n    // console.log(\"fontPromise.fetch\", type)\n    if (!isPopulatedString(type) || type.startsWith(FontType)) {\n      return response.arrayBuffer()\n    }\n    assertTrue(type.startsWith(CssContentType)) \n    \n    return response.text().then(string => {\n      // TODO: use resolverPromise instead\n      // return resolverPromise(string, type, FontType)\n      const cssUrl = urlFromCss(string)\n      // console.log(\"fontPromise.fetch CSS\", cssUrl)\n      return arrayBufferPromise(cssUrl)\n    })\n  })\n    \n  const family = fontFamily(url)\n  // console.log(\"fontPromise\", url)\n  const facePromise = bufferPromise.then(buffer => {\n    // console.log(\"fontPromise.bufferPromise\", url)\n    const face = new FontFace(family, buffer)\n    return face.load()\n  })\n  return facePromise.then(face => {\n    // console.log(\"fontPromise.facePromise\", url)\n    const { fonts } = globalThis.document\n    fonts.add(face)\n    return fonts.ready.then(() => {\n      \n      // console.log(\"fontPromise.ready\", url)\n      // this.updateLoaderFile(file, info)\n      return { data: face }\n    })\n  })\n}\n\nconst audioPromise =  (request: Request): Promise<AudioDataOrError> => {\n  const { endpoint, init } = request\n  assertEndpoint(endpoint)\n\n  const url = endpointUrl(endpoint)\n  // console.log(this.constructor.name, \"audioPromise\", isBlob ? 'BLOB' : url)\n  return arrayBufferPromise(url, init).then(audioBufferPromise)\n}\n\nconst promise: ProtocolPromise = ((request: Request, type?: LoadType) => {\n  const { endpoint, init } = request\n  assertEndpoint(endpoint)\n\n  const absolute = endpointAbsolute(endpoint)\n  const absoluteRequest = { init, endpoint: absolute }\n  // console.log('http promise', endpoint, absolute)\n  switch (type) {\n    case ImageType: return imageDataPromise(absoluteRequest)\n    case AudioType: return audioPromise(absoluteRequest)\n    case VideoType: return videoDataPromise(absoluteRequest)\n    case FontType: return fontPromise(absoluteRequest)\n    case RecordType: return jsonPromise(absoluteRequest) \n    case RecordsType: return jsonPromise(absoluteRequest)\n  }\n  errorThrow(type, 'LoadType', 'type')\n}) \n\nPlugins[ProtocolType][HttpProtocol] = { promise, type: HttpProtocol }\nPlugins[ProtocolType][HttpsProtocol] = { promise, type: HttpsProtocol }\n","import { \n  ProtocolPromise, Plugins, Request, AudioType, ImageType, VideoType, \n  BlobProtocol, JsonType, PathData, ProtocolType\n} from \"@moviemasher/moviemasher.js\"\nimport { audioDataPromise } from \"../Utility/Audio\"\nimport { imageDataPromise } from \"../Utility/Image\"\nimport { jsonPromise } from \"../Utility/Json\"\nimport {  videoDataPromise } from \"../Utility/Video\"\n\n\n\nconst promise: ProtocolPromise = ((request: Request, type?: string) => {\n  // console.log('blob promise', url, absolute, endpoint)\n  switch (type) {\n    case AudioType: return audioDataPromise(request)\n    case ImageType: return imageDataPromise(request)\n    case VideoType: return videoDataPromise(request)\n    case JsonType: return jsonPromise(request)\n    // case FontType: return requestFontPromise(request)\n    // case FontType: return errorThrow(type, 'LoadType', 'type')//fontPromise(url)\n    default: {\n      const result: PathData = { path: '' }\n      return Promise.resolve(result)\n    }\n  }\n}) \n\n\n\nPlugins[ProtocolType][BlobProtocol] = { promise, type: BlobProtocol }\n\n","import {\n  UnknownRecord, \n  Clip, Point, isString, Rect, isObject, isMediaType, \n  MediaType, assertMediaType, StringsRecord, NumberRecord, \n  JsonRecord, isRawType, isAboveZero, isPopulatedString, isArray, \n  DroppingPosition, isUndefined, ClassDropping, ClassDroppingAfter, \n  ClassDroppingBefore, isPopulatedObject, errorThrow, MediaObject, \n  MashAndMediaObject, MediaTypes, mediaTypeFromMime, Strings\n} from \"@moviemasher/moviemasher.js\"\n\nexport const DragSuffix = '/x-moviemasher'\n\nexport type FileInfo = File | UnknownRecord\nexport type FileInfos = FileInfo[]\n\nexport interface DragOffsetObject {\n  offset: number\n}\nexport const isDragOffsetObject = (value: any): value is DragOffsetObject => {\n  return isObject(value) && \"offset\" in value\n}\nexport function assertDragOffsetObject(value: any): asserts value is DragOffsetObject {\n  if (!isDragOffsetObject(value)) errorThrow(value, 'DragOffsetObject')\n}\n\nexport interface DragDefinitionObject extends DragOffsetObject {\n  mediaObject: UnknownRecord\n}\nexport const isDragDefinitionObject = (value: any): value is DragDefinitionObject => {\n  return isDragOffsetObject(value) && \"mediaObject\" in value && isObject(value.mediaObject)\n}\nexport function assertDragDefinitionObject(value: any): asserts value is DragDefinitionObject {\n  if (!isDragDefinitionObject(value)) errorThrow(value, 'DragDefinitionObject')\n}\n\nexport interface DragLayerObject extends UnknownRecord {\n  offset: number\n  mashAndMedia?: MashAndMediaObject\n}\n\n\nexport type Draggable = MediaObject | MashAndMediaObject | Clip | FileList\n\n\nexport const TransferTypeFiles = \"Files\"\nexport type TransferType = string \nexport const isTransferType = (value: any): value is TransferType => {\n  return isString(value) && value.endsWith(DragSuffix)\n}\n// \nexport const dropType = (dataTransfer?: DataTransfer | null): TransferType | undefined => {\n  if (!dataTransfer) return\n  \n  return dataTransfer.types.find(isTransferType)\n}\n\nexport const dragMediaType = (transferType: TransferType): MediaType => {\n  const [type] = transferType.split('/')\n  assertMediaType(type)\n  return type\n}\n\nexport const dragType = (dataTransfer?: DataTransfer | null): MediaType | undefined => {\n  const prefix = dropType(dataTransfer)\n  if (!prefix) return\n\n  const [type] = prefix.split('/')\n  if (isMediaType(type)) return type\n}\n\nexport const dragTypes = (dataTransfer: DataTransfer): Strings => {\n  const { types } = dataTransfer\n  return types.filter(type => (\n    type === TransferTypeFiles || isTransferType(type)\n  ))\n}\n\nexport const dragData = (dataTransfer: DataTransfer, type?: TransferType) => {\n  const transferType = type ? `${type}${DragSuffix}` : dragTypes(dataTransfer).find(isTransferType)\n  if (!transferType) return {}\n\n  const json = dataTransfer.getData(transferType)\n  // console.log(\"dragData\", json, type, transferType)\n  const data = json ? JSON.parse(json) : {}\n  return data\n}\n\nexport const DragElementRect = (current: Element): Rect => current.getBoundingClientRect()\n\nexport const DragElementPoint = (event: DragEvent, current: Element | Rect,): Point => {\n  const rect = (current instanceof Element) ? DragElementRect(current) : current\n  const { x, y } = rect\n  const { clientY, clientX } = event\n  return { x: clientX - x, y: clientY - y }\n}\n\nexport const dropFilesFromList = (files: FileList, serverOptions: JsonRecord = {}): FileInfos => {\n  const infos: FileInfos = []\n  const { length } = files\n  if (!length) return infos\n\n  const exists = isPopulatedObject(serverOptions)\n  const { extensions = {}, uploadLimits = {} } = serverOptions\n  const extensionsByType = extensions as StringsRecord\n  const limitsByType = uploadLimits as NumberRecord\n\n  for (let i = 0; i < length; i++) {\n    const file = files.item(i)\n    if (!file) continue\n\n    const { name, size, type } = file\n    const coreType = mediaTypeFromMime(type) \n    if (!isRawType(coreType)) {\n      infos.push({ label: name, value: coreType, error: 'import.type' })\n      continue\n    }\n    \n    const max = limitsByType[coreType]\n    if (exists && !(isAboveZero(max) && max * 1024 * 1024 > size)) {\n      infos.push({ label: name, value: `${max}MB`, error: 'import.bytes' })\n      continue\n    }\n\n    const ext = name.toLowerCase().split('.').pop()\n    const extDefined = isPopulatedString(ext)\n    const exts = extensionsByType[coreType]\n    if (exists || !extDefined) {\n      if (!(extDefined && isArray(exts) && exts.includes(ext))) {\n        infos.push({ label: name, value: ext, error: 'import.extension' })\n        continue\n      } \n    }\n    infos.push(file)\n  }\n  console.log('dropFilesFromList infos', infos)\n  return infos\n}\n\n\nexport const droppingPositionClass = (droppingPosition?: DroppingPosition | number): string => {\n  if (isUndefined(droppingPosition)) return ''\n\n  switch (droppingPosition) {\n    case DroppingPosition.After: return ClassDroppingAfter\n    case DroppingPosition.Before: return ClassDroppingBefore\n    case DroppingPosition.None: return ''\n  }\n  return ClassDropping\n}\n","import { roundWithMethod } from \"@moviemasher/moviemasher.js\"\n\nexport const pixelPerFrame = (frames: number, width: number, zoom = 1): number => {\n  if (!(frames && width)) return 0\n\n  const widthFrames = width / frames\n\n  const min = Math.min(1, widthFrames)\n  const max = Math.max(1, widthFrames)\n  if (zoom === 1) return max\n  if (!zoom) return min\n\n  return min + ((max - min) * zoom)\n}\n\nexport const pixelFromFrame = (frame: number, perFrame : number, rounding = 'ceil'): number => {\n  if (!(frame && perFrame)) return 0\n\n  const pixels = frame * perFrame\n  return roundWithMethod(pixels, rounding)\n}\n","import { Identified } from \"@moviemasher/moviemasher.js\"\n\n\n\nexport enum ActivityType {\n  Analyze = 'analyze',\n  Complete = 'complete',\n  Error = \"error\",\n  Load = 'load',\n  Render = 'render',\n}\n\nexport interface ActivityInfo extends Identified {\n  type: ActivityType\n  label?: string\n  steps?: number\n  step?: number\n  error?: string\n  value?: string\n}\n"],"names":["i","E","m","A","M","S","j","N","o","includes","$t","_$t","_defineProperty","k","_k","autoDecode","_autoDecode","y","type","h","options","types","V","se","_","L","ce","ie","autoGet","ae","order","created_at","pe","getRequest","endpoint","pathname","f","listRequest","autoTranscode","outputType","accept","de","concat","saveRequest","deleteRequest","uploadRequest","uploadResponseIsRequest","uploadCookedTypes","C","e","_classCallCheck","_createClass","key","value","r","this","clientArgs","write","n","Te","join","every","Error","t","ue","saveMash","step","steps","media","completed","saveMedia","Promise","resolve","arguments","length","undefined","_this$options","_objectSpread","_this","definitionIds","filter","W","map","s","fromId","mash","saveMedias","then","error","saveMediaRow","g","O","id","errorPromise","a","p","init","l","definition","toJSON","body","fe","c","le","T","data","upload","Oe","console","log","constructor","name","updateDefinitionId","Object","assign","Pe","file","request","response","ye","loadedVideo","Re","loadedAudio","Ce","loadedImage","tracks","flatMap","clips","forEach","containerId","setValue","contentId","reload","_this2","xe","me","ge","ho","he","SUPABASE_PROJECT_URL","SUPABASE_ANON_KEY","SUPABASE_BUCKET","SUPABASE_EXPIRES","SUPABASE_TABLE","H","_H","wo","De","be","J","Ee","Se","Ae","fetch","blob","FileReader","onload","result","onerror","readAsArrayBuffer","ve","v","Me","catch","je","P","we","json","_t$headers","_o$init","qe","method","headers","JSON","stringify","FormData","entries","_ref","_ref2","_slicedToArray","d","Ie","set","Blob","String","Be","R","Ve","Ue","Image","src","_e","Fe","x","He","Le","globalThis","document","ke","Ne","createElement","Je","oncanplay","videoWidth","clientWidth","videoHeight","clientHeight","width","height","We","autoplay","load","Z","arrayBuffer","Q","I","Ye","Ge","Ze","$","it","Qe","z","get","Xe","startsWith","Ke","$e","text","ze","replaceAll","rt","FontFace","fonts","add","ready","nt","tt","ot","et","Y","G","K","promise","X","st","lt","ee","at","pt","dt","ct","path","re","ne","te","Ur","oe","Et","mediaObject","Fr","At","q","ft","endsWith","Mt","find","_r","_o$split","split","gt","Vr","_e$split","mt","St","Lr","getData","parse","jt","getBoundingClientRect","Nr","Element","clientY","clientX","kr","bt","_e$extensions","extensions","_e$uploadLimits","uploadLimits","item","w","size","u","ht","Ot","D","Pt","b","toLowerCase","pop","U","yt","F","Ct","push","label","Wr","Rt","B","Tt","Dt","xt","Kr","Math","min","max","Xr","vt","It","Analyze","Complete","Load","Render"],"sourceRoot":""}