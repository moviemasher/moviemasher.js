{
  "version": 3,
  "sources": ["../src/Client/Client.ts", "../src/Client/ClientClass.ts", "../src/Client/ClientFactory.ts", "../src/Config/Config.ts", "../src/Protocol/Http.ts", "../src/Utility/Audio.ts", "../src/Utility/Json.ts", "../src/Utility/Image.ts", "../src/Utility/Video.ts", "../src/Protocol/Blob.ts", "../src/Utility/DragDrop.ts", "../src/Utility/Pixel.ts", "../src/Utility/Activity.ts"],
  "sourcesContent": ["import { \n  AlphaProbe, AudibleProbe, AudioType, CookedTypes, DecodeOutput, Decoding, \n  DurationProbe, Encoding, Endpoints, ImageType, LoadType, MashMedia, MashType, \n  Media, MediaType, MediaTypes, OrderDecending, PotentialError, ProbeType, \n  RawTypes, Request, SizeProbe, StringRecord, Strings, TranscodeOutput, \n  Transcoding, VideoType \n} from \"@moviemasher/moviemasher.js\"\n\nexport interface DecodeTypesByMediaType extends Record<LoadType, DecodeOutput[]> {}\nexport interface TranscodingTypesByMediaType extends Record<LoadType, TranscodeOutput[]> {}\n\n\nexport type ReadOperation = 'read'\nexport type WriteOperation = 'write'\nexport type TranscodeOperation = 'transcode'\nexport type EncodeOperation = 'encode'\nexport type DecodeOperation = 'decode'\nexport const ReadOperation: ReadOperation = 'read'\nexport const WriteOperation: WriteOperation = 'write'\nexport const TranscodeOperation: TranscodeOperation = 'transcode'\nexport const EncodeOperation: EncodeOperation = 'encode'\nexport const DecodeOperation: DecodeOperation = 'decode'\n\nexport type Operation = ReadOperation | WriteOperation | TranscodeOperation | EncodeOperation | DecodeOperation\nexport type Operations = Operation[]\nexport const Operations: Operations = [ReadOperation, WriteOperation, TranscodeOperation, EncodeOperation, DecodeOperation]\nexport const isOperation = (value: any): value is Operation => {\n  return Operations.includes(value)\n}\n\n\nexport interface Client {\n  accept(options?: ClientSaveOptions): string | undefined\n  enabled(operation?: Operation): boolean\n  decode(options: ClientDecodeOptions): Promise<Decoding>\n  encode(mashMedia: MashMedia, options?: ClientEncodeOptions): Promise<Encoding>\n  list(options?: ClientReadOptions): Promise<ClientArrayResponse>\n  get(options?: ClientReadOptions): Promise<ClientObjectResponse>\n\n  save(media: Media, options?: ClientSaveOptions): Promise<ClientObjectResponse>\n  transcode(options: ClientTranscodeOptions): Promise<Transcoding>\n}\n\n\nexport interface ClientDecodeOptions { \n  autoDecode?: DecodeTypesByMediaType | false\n}\n\nexport interface ClientEncodeOptions {\n  autoTranscode?: TranscodingTypesByMediaType | false\n}\n\nexport interface ClientTranscodeOptions {\n  autoTranscode?: TranscodingTypesByMediaType | false\n}\nexport interface ClientReadParams {\n  type?: MediaType | MediaTypes\n  kind?: string | Strings\n  order?: string | StringRecord\n}\nexport interface ClientReadOptions extends ClientReadParams {\n  autoGet?: ClientReadParams | false\n  getRequest?: Request | false\n  listRequest?: Request | false\n}\n\nexport interface ClientArgs extends Required<ClientOptions> {}\n\nexport interface ClientWriteOptions {\n  accept?: string | Strings \n  saveRequest?: Request | false\n  deleteRequest?: Request | false\n  uploadRequest?: Request | false\n  uploadResponseIsRequest?: boolean\n  uploadCookedTypes?: CookedTypes\n}\n\nexport interface ClientOptions {\n  [ReadOperation]?: ClientReadOptions | false | undefined\n  [WriteOperation]?: ClientWriteOptions | false | undefined\n  [DecodeOperation]?: ClientDecodeOptions | false | undefined\n  [EncodeOperation]?: ClientEncodeOptions | false | undefined\n  [TranscodeOperation]?: ClientTranscodeOptions | false | undefined\n} \n\n\nexport const ClientDisabledArgs: ClientArgs = {\n  [ReadOperation]: false,\n  [WriteOperation]: false,\n  [DecodeOperation]: false,\n  [EncodeOperation]: false,\n  [TranscodeOperation]: false,\n}\n\nexport const ClientDefaultArgs: ClientArgs = {\n  [DecodeOperation]: {\n    autoDecode: {\n      [AudioType]: [{ \n        type: ProbeType, \n        options: { types: [DurationProbe] }\n      }],\n      [ImageType]: [{ \n        type: ProbeType, \n        options: { types: [AlphaProbe, SizeProbe] }\n      }],\n\n      [VideoType]: [{ \n        type: ProbeType, \n        options: { \n          types: [\n            DurationProbe, SizeProbe, \n            AlphaProbe, AudibleProbe \n          ] \n        }\n      }],\n    },\n  },\n  [EncodeOperation]: {\n\n  },\n  [ReadOperation]: {\n    autoGet: { type: MashType, order: { created_at: OrderDecending }},\n    getRequest: { endpoint: { pathname: Endpoints.data.definition.get } }, \n    listRequest: { endpoint: { pathname: Endpoints.data.definition.retrieve } },\n      \n  },\n  [TranscodeOperation]: {\n    autoTranscode: {\n      [AudioType]: [\n        { \n          type: AudioType, \n          options: { outputType: AudioType } \n        }\n      ],\n    },\n  },\n  [WriteOperation]: {\n    accept: RawTypes.map(type => `${type}/*`),\n    saveRequest: { endpoint: { pathname: Endpoints.data.definition.put} }, \n    deleteRequest: { endpoint: { pathname: Endpoints.data.definition.delete } }, \n    uploadRequest: { endpoint: { pathname: Endpoints.data.definition.retrieve } },\n    uploadResponseIsRequest: true,\n    uploadCookedTypes: [],\n  },\n}\n\nexport interface ClientSaveOptions extends ClientOptions {\n  callback?: ClientCallback\n}\n\nexport interface ClientProgress extends PotentialError {\n  mash?: MashMedia\n  media: Media\n  processing?: Transcoding | Encoding | Decoding\n  completed: number\n}\n\nexport interface ClientProgessSteps extends ClientProgress {\n  steps: number\n  step: number\n}\n\nexport type ClientCallback = (progress: ClientProgress) => void\n\n\nexport interface ClientArrayResponse extends PotentialError {\n  data?: Media[]\n}\nexport interface ClientObjectResponse extends PotentialError {\n  data?: Media\n}\n\nexport type ClientSaveResponse = ClientArrayResponse | ClientObjectResponse\n\n\n\n", "import { \n  assertIdentified, DataDefinitionPutRequest, DataDefinitionPutResponse, \n  Decoding, Encoding, isMashMedia, MashMedia, Media, MediaObject, MediaArray, \n  requestRecordPromise, Transcoding, transcodingInstance, VideoType, \n  Request, ErrorName, error, idIsTemporary, assertPopulatedString, isMedia, \n  isVideoMedia, isImageMedia, isUpdatableDurationDefinition, \n  PotentialError, ProbeType, isArray, \n} from \"@moviemasher/moviemasher.js\"\n\nimport { \n  Client, ClientOptions, ClientDecodeOptions, ClientEncodeOptions, \n  ClientReadOptions, ClientSaveOptions, ClientTranscodeOptions, \n  ClientObjectResponse, ClientProgessSteps, ClientArrayResponse, \n  ClientDefaultArgs, ClientArgs, Operation, isOperation, Operations, WriteOperation} from \"./Client\"\n\n\nexport class ClientClass implements Client {\n  constructor(public options?: ClientOptions) {}\n\n  accept(options?: ClientSaveOptions): string | undefined { \n    const args = this.clientArgs(options)\n    const { write } = args\n    if (!write) return \n\n    const { accept } = write\n    return isArray(accept) ? accept.join(',') : accept\n  }\n\n\n  enabled(operation?: Operation): boolean {\n    const operations = isOperation(operation) ? [operation] : Operations\n    return operations.every(operation => {\n\n    })\n  }\n\n  get(options?: ClientReadOptions | undefined): Promise<ClientObjectResponse> {\n       throw new Error(\"Method not implemented.\")\n \n  }\n  list(args: ClientReadOptions): Promise<ClientArrayResponse> {\n    throw new Error(\"Method not implemented.\")\n  }\n  save(media: Media, options?: ClientSaveOptions): Promise<ClientObjectResponse> {\n    const args = this.clientArgs(options)\n\n    if (isMashMedia(media)) return this.saveMash(media, args) \n    \n    const steps: ClientProgessSteps = {\n      step: 0, steps: 2, media, completed: 0\n    }\n    this.saveMedia(media, steps, args)\n    \n    const response: ClientObjectResponse = {}\n    return Promise.resolve(response)\n  }\n\n  private clientArgs(clientOptions: ClientOptions = {}): ClientArgs {\n    const { options = {}} = this\n    return { ...ClientDefaultArgs, ...options, ...clientOptions }\n  }\n  \n  protected saveMash(mash: MashMedia, args: ClientArgs): Promise<ClientObjectResponse> {\n    const temporaryIds = mash.definitionIds.filter(idIsTemporary)\n    const temporaryMedia = temporaryIds.map(id => mash.media.fromId(id))\n\n    const steps: ClientProgessSteps = {\n      step: 0, steps: 1, mash, media: mash, completed: 0\n    }\n    \n    return this.saveMedias(temporaryMedia, steps, args).then(result => \n      result.error ? result : this.saveMediaRow(mash, steps, args)\n    )\n  }\n    // const definitionsPromise = saveDefinitionsPromise(definitionsUnsaved)\n    // const requestPromise = definitionsPromise.then(() => editor.dataPutRequest())\n    // const savePromise = requestPromise.then(request => {\n    //   // const { editType } = editor\n    //   console.debug(\"DataPutRequest\", Endpoints.data[editType].put, JSON.parse(JSON.stringify(request)))\n    //   endpointPromise(Endpoints.data[editType].put, request).then((response: DataPutResponse) => {\n    //     console.debug(\"DataPutResponse\", Endpoints.data[editType].put, response)\n    //     const { error, temporaryIdLookup } = response\n    //     if (error) console.error(Endpoints.data[editType].put, error)\n    //     else editor.saved(temporaryIdLookup)\n    //   })\n    // })\n\n\n  // dataPutRequest(): Promise<DataPutRequest> {\n  //   const { mashMedia, editType } = this\n  //   assertObject(mashMedia, 'edited')\n  //   assertEditType(editType)\n\n  //   // set edit's label if it's empty\n  //   const { label } = mashMedia \n  //   if (!isPopulatedString(label)) {\n  //     const defaultLabel = Default[editType].label\n  //     assertPopulatedString(defaultLabel, 'defaultLabel')\n  //     mashMedia.setValue(defaultLabel, 'label')\n  //   }\n  \n  //   return mashMedia.putPromise().then(() => {\n  //     if (isMashMedia(mashMedia)) {\n  //       return {\n  //         mash: mashMedia.toJSON(),\n  //         definitionIds: mashMedia.definitionIds\n  //       }\n  //     } \n  //   })\n  // }\n\n\n  private errorPromise(code: ErrorName = ErrorName.Internal): Promise<PotentialError> {\n    return Promise.resolve(error(code))\n  }\n  protected saveMediaRow(media: Media, steps: ClientProgessSteps, args: ClientArgs): Promise<ClientObjectResponse> {\n    const { id, type } = media\n    const options = args[WriteOperation]\n    if (!options) return this.errorPromise()\n\n    const { saveRequest } = options\n    if (!saveRequest) return this.errorPromise()\n\n\n    const requestObject: Request = { ...saveRequest }\n    requestObject.init ||= {}\n    const definition: MediaObject = { id, ...media.toJSON() }\n    const request: DataDefinitionPutRequest = { definition }\n    requestObject.init.body = request\n    return requestRecordPromise(requestObject).then(result => {\n      assertIdentified(result)\n      const { id, error } = result as DataDefinitionPutResponse\n      steps.step++\n      const response: ClientObjectResponse = { error, data: media }\n      return response\n    })\n  }\n\n  protected saveAutoDecodings(media: Media, steps: ClientProgessSteps, args: ClientArgs): Promise<ClientObjectResponse> {\n    return Promise.resolve(error(ErrorName.ClientDisabledDelete))\n\n  }\n\n\n  \n  protected upload(media: Media, steps: ClientProgessSteps, args: ClientArgs): Promise<ClientObjectResponse> {\n    return Promise.resolve(error(ErrorName.ClientDisabledDelete))\n    //   const { uploadResponseIsRequest, uploadCookedTypes } = args\n\n  //   if (uploadResponseIsRequest) {\n\n  //   }\n\n  //   const { label, type, clientMedia } = media\n  //   if (!clientMedia) return Promise.resolve(error(ErrorName.Internal))\n  \n  //   if (isRawType(type)) {\n  //     type\n  //   }\n  //   switch (type) {\n  //     case AudioType:\n  //     case ImageType:\n  //     case VideoType:\n        \n  //       break;\n    \n  //     default:\n  //       break;\n  //   }\n\n\n  //   const id = idGenerate('activity')\n  \n  //   const { rendering } = Endpoints\n  //   console.log(\"Masher fetch\", source)\n  //   const responsePromise = fetch(source)\n  //   const blobPromise = responsePromise.then(response => response.blob())\n  //   const filePromise = blobPromise.then(blob => new File([blob], label))\n  //   const resultPromise = filePromise.then(file => {\n  //     const request: RenderingUploadRequest = { type, name: label, size: file.size }\n  //     console.debug(\"RenderingUploadRequest\", rendering.upload, request)\n  //     const responsePromise = endpointPromise(rendering.upload, request)\n  //     return responsePromise.then((response: RenderingUploadResponse) => {\n  //       console.debug(\"RenderingUploadResponse\", rendering.upload, response)\n  //       const { error, fileApiCallback, apiCallback, fileProperty } = response\n  //       if (error) return handleError(rendering.upload, error, id)\n  \n  //       else if (fileApiCallback && fileApiCallback.init) {\n  //         if (fileProperty) fileApiCallback.init.body![fileProperty] = file\n  //         else fileApiCallback.init.body = file\n  //         return jsonPromise(fileApiCallback).then((response: FileStoreResponse) => {\n  //           console.debug(\"FileStoreResponse\", response)\n  //           const { error } = response\n  //           if (error) return handleError(fileApiCallback.endpoint.pathname!, error, id)\n  \n  //           assertObject(apiCallback, 'apiCallback')\n  //           return handleApiCallback(id, definition, apiCallback)\n  //         })\n  //       } \n  //       assertObject(apiCallback, 'apiCallback')\n  //       return handleApiCallback(id, definition, apiCallback)\n  //     })\n  //  })\n  }\n  protected saveUpload(media: Media, steps: ClientProgessSteps, args: ClientArgs): Promise<ClientObjectResponse> {\n    const { id } = media\n    if (idIsTemporary(id)) return this.upload(media, steps, args)\n\n    return this.saveMediaRow(media, steps, args)\n  }\n\n  protected saveAutoTranscodings(media: Media, steps: ClientProgessSteps, args: ClientArgs): Promise<ClientObjectResponse> {\n    return Promise.resolve(error(ErrorName.ClientDisabledDelete))\n\n  }\n\n  \n  protected saveMedia(media: Media, steps: ClientProgessSteps, args: ClientArgs): Promise<ClientObjectResponse> {\n    return Promise.resolve(error(ErrorName.ClientDisabledDelete))\n\n    // steps.media = media\n    // const { autoDecode, autoTranscode } = args\n\n    // const { id, type, transcodings, decodings } = media\n    // return this.saveUpload(media, steps, args).then(result => (\n    //   result.error ? result : this.saveAutoDecodings(media, steps, args)\n    // ))\n\n    // if (!decodings.length && autoDecode && autoDecode[type])\n\n    // return this.saveMediaRow(media, steps, args)\n\n    \n  }\n\n\n  private updateMedia(mediaObject: MediaObject, mash: MashMedia, media?: Media): Promise<void> {\n    \n    const {id: newId } = mediaObject\n    const id = mediaObject.id || media!.id\n    assertPopulatedString(id)\n\n    const target = media || mash.media.fromId(newId!)\n    const { id: oldId } = target\n    const idChanged = oldId !== id\n    console.log(this.constructor.name, \"updateDefinition\", idChanged, mediaObject)\n    if (idChanged) {\n      mash.media.updateDefinitionId(target.id, id)\n      console.log(this.constructor.name, \"updateDefinition called updateDefinitionId\", target.id, id)\n\n      // TODO - replace assign\n      Object.assign(target, mediaObject)\n      \n      if (isMedia(target)) {\n        delete target.file\n        delete target.request.response \n        if (isVideoMedia(target)) {\n          delete target.loadedVideo \n        }\n        else if (isUpdatableDurationDefinition(target)) delete target.loadedAudio \n        else if (isImageMedia(target)) delete target.loadedImage \n      }    \n    } \n    if (!idChanged) return Promise.resolve()\n    \n    const { tracks } = mash\n    const clips = tracks.flatMap(track => track.clips)\n    clips.forEach(clip => {\n      if (clip.containerId === oldId) clip.setValue(newId, 'containerId')\n      if (clip.contentId === oldId) clip.setValue(newId, 'contentId')\n    })\n    return mash.reload() || Promise.resolve()\n  }\n\n  protected saveMedias(mediaArray: MediaArray, steps: ClientProgessSteps, args: ClientArgs): Promise<ClientObjectResponse> {\n    let promise: Promise<ClientObjectResponse> = Promise.resolve({})\n    mediaArray.forEach(media => {\n      promise = promise.then(result => (\n        result.error ? result : this.saveMedia(media, steps, args)\n      ))\n    })\n\n    return promise\n  }\n\n  decode(args: ClientDecodeOptions): Promise<Decoding> {\n    return Promise.resolve({ type: ProbeType })\n  }\n\n  encode(mashMedia: MashMedia, args: ClientEncodeOptions): Promise<Encoding> {\n    throw new Error(\"Method not implemented.\")\n\n    // const media = editor.definitions.map(object => object.toJSON()) as MediaObjects\n    // const mashObject = mashMedia.toJSON() as MashMediaObject\n    // const mash: MashAndMediaObject = { ...mashObject, media }\n    // const request: RenderingStartRequest = {\n    //   mash,\n    //   output: {outputType: VideoType},\n    // }\n    // console.debug(\"RenderingStartRequest\", Endpoints.rendering.start, request)\n    // endpointPromise(Endpoints.rendering.start, request).then((response: RenderingStartResponse) => {\n    //   console.debug(\"RenderingStartResponse\", Endpoints.rendering.start, response)\n    //   const { apiCallback, error } = response\n    //   if (error) handleError(Endpoints.rendering.start, request, response, error.message)\n    //   else handleApiCallback(apiCallback!, mashMedia)\n    // })\n\n\n  }\n\n  transcode(args: ClientTranscodeOptions): Promise<Transcoding> {\n    const transcodingobject = { type: VideoType, id: '', request: { endpoint: {}}}\n    const transcoding = transcodingInstance(transcodingobject)\n    return Promise.resolve(transcoding)\n\n  }\n}\n\n\n// let promise = Promise.resolve()\n\n// definitions.forEach(definition => {\n//   assertContentDefinition(definition)\n//   const { label, type, source } = definition\n\n//   const id = idGenerate('activity')\n//   eventTarget.emit(EventType.Active, { id, label, type: ActivityType.Render })\n\n//   const { rendering } = Endpoints\n//   console.log(\"Masher fetch\", source)\n//   const responsePromise = fetch(source)\n//   const blobPromise = responsePromise.then(response => response.blob())\n//   const filePromise = blobPromise.then(blob => new File([blob], label))\n//   const resultPromise = filePromise.then(file => {\n//     const request: RenderingUploadRequest = { type, name: label, size: file.size }\n//     console.debug(\"RenderingUploadRequest\", rendering.upload, request)\n//     const responsePromise = endpointPromise(rendering.upload, request)\n//     return responsePromise.then((response: RenderingUploadResponse) => {\n//       console.debug(\"RenderingUploadResponse\", rendering.upload, response)\n//       const { error, fileApiCallback, apiCallback, fileProperty } = response\n//       if (error) return handleError(rendering.upload, error, id)\n\n//       else if (fileApiCallback && fileApiCallback.init) {\n//         if (fileProperty) fileApiCallback.init.body![fileProperty] = file\n//         else fileApiCallback.init.body = file\n//         return jsonPromise(fileApiCallback).then((response: FileStoreResponse) => {\n//           console.debug(\"FileStoreResponse\", response)\n//           const { error } = response\n//           if (error) return handleError(fileApiCallback.endpoint.pathname!, error, id)\n\n//           assertObject(apiCallback, 'apiCallback')\n//           return handleApiCallback(id, definition, apiCallback)\n//         })\n//       } \n//       assertObject(apiCallback, 'apiCallback')\n//       return handleApiCallback(id, definition, apiCallback)\n//     })\n//   })\n//   promise = promise.then(() => resultPromise)\n// })\n\n\n\n// from rendering server class \n\n  // private populateDefinition(user: string, renderingId: string, definition: MediaObject, commandOutputs: RenderingCommandOutputs): void {\n  //   const { fileServer } = this\n  //   assertTrue(fileServer)\n\n  //   const { id, source, type: definitionType } = definition\n  //   assertPopulatedString(id)\n  //   assertMediaType(definitionType)\n  //   assertPopulatedString(source)\n\n  //   const prefix = path.join(fileServer.userUploadPrefix(id, user), renderingId)\n  //   const outputDirectory = this.outputDirectory(user, id)\n  //   const inInfoName = `upload.${ExtensionLoadedInfo}`\n  //   const inInfoPath = path.join(outputDirectory, renderingId, inInfoName)\n  //   const inInfoExists = fs.existsSync(inInfoPath)\n  //   const inInfo: ProbingData = inInfoExists ? expandToJson(inInfoPath) : {}\n  //   const { \n  //     width: inWidth, height: inHeight,\n  //     duration: inDuration, audible: inAudible, label: inLabel\n  //   } = inInfo\n  //   if (isUpdatableDurationType(definitionType) && isAboveZero(inDuration)) {\n  //     definition.duration = inDuration\n  //   }\n  //   if (isUpdatableSizeType(definitionType)) {\n  //     if (isAboveZero(inWidth) && isAboveZero(inHeight)) {\n  //       definition.sourceSize = { width: inWidth, height: inHeight }\n  //     }\n  //   }\n  //   const countByType: NumberRecord = {}\n  //   commandOutputs.forEach(output => {\n  //     const { outputType } = output\n  //     if (!isDefined(countByType[outputType])) countByType[outputType] = -1\n  //     countByType[outputType]++\n  //     const index = countByType[outputType]\n  //     const outInfoName = renderingOutputFile(index, output, ExtensionLoadedInfo)\n  //     const outInfoPath = path.join(outputDirectory, renderingId, outInfoName)\n\n  //     const outInfo: ProbingData = expandToJson(outInfoPath)\n  //     const { \n  //       width: outWidth, height: outHeight, \n  //       duration: outDuration, audible: outAudible, extension\n  //     } = outInfo\n  //     const outputFilename = renderingOutputFile(index, output, extension)\n  //     const outUrl = path.join(prefix, outputFilename)\n  //     // console.log(this.constructor.name, \"populateDefinition\", outInfo, index, outputType, outUrl)\n  //     switch(outputType) {\n  //       // case EncodeType.ImageSequence: {\n  //       //   if (isAboveZero(outWidth) && isAboveZero(outHeight)) {\n  //       //     definition.fps = output.videoRate\n  //       //     definition.previewSize = { width: outWidth, height: outHeight }\n  //       //     definition.url = prefix + '/'\n  //       //   } \n  //       //   break\n  //       // }\n  //       case EncodeType.Audio: {\n  //         const { duration: definitionDuration } = definition\n  //         if (isAboveZero(outDuration) && isAboveZero(definitionDuration)) {\n  //           definition.audio = true\n  //           definition.duration = Math.min(definitionDuration, outDuration)\n  //           const audioInput = definitionType === AudioType\n  //           if (audioInput) definition.url = outUrl\n  //           else definition.audioUrl = outUrl\n  //         }\n  //         break\n  //       }\n  //       case EncodeType.Image: {\n  //         if (isAboveZero(outWidth) && isAboveZero(outHeight)) {\n  //           const outSize = { width: outWidth, height: outHeight }\n  //           const imageInput = definitionType === ImageType\n  //           if (imageInput && !index) {\n  //             definition.previewSize = outSize\n  //             definition.url = outUrl\n  //           } else definition.icon = outUrl\n  //         }\n  //         break\n  //       }\n  //     }\n  //   })\n  //   // console.log(this.constructor.name, \"populateDefinition\", definition)\n  // }\n  // private _renderingCommandOutputs?: UnusedRenderingCommandOutputs\n  // private get renderingCommandOutputs(): UnusedRenderingCommandOutputs {\n  //   if (this._renderingCommandOutputs) return this._renderingCommandOutputs\n\n  //   const { previewSize, outputSize } = this\n  //   const provided = this.args.commandOutputs || {}\n  //   const outputs = Object.fromEntries(EncodeTypes.map(outputType => {\n  //     const base: RenderingCommandOutput = { outputType }\n  //     switch (outputType) {\n  //       case EncodeType.Image: {\n  //         base.width = previewSize.width\n  //         base.height = previewSize.height\n  //         base.cover = true\n  //         break\n  //       }\n  //       case EncodeType.Video: {\n  //         base.width = outputSize.width\n  //         base.height = outputSize.height\n  //         break\n  //       }\n  //     }\n  //     const commandOutput: CommandOutput = provided[outputType] || {}\n  //     const renderingCommandOutput: RenderingCommandOutput = { ...base, ...commandOutput }\n  //     return [outputType, renderingCommandOutput]\n  //   }))\n  //   return this._renderingCommandOutputs = outputs\n  // }\n\n\n  // FROM Masher.tsx\n\n    // const handleApiCallback = (id: string, definition: Media, callback: ApiCallback): Promise<void> => {\n  //   console.debug(\"handleApiCallback request\", callback)\n  //   const { eventTarget } = editor\n  //   return jsonPromise(callback).then((response: ApiCallbackResponse) => {\n  //     console.debug(\"handleApiCallback response\", response)\n  //     const { apiCallback, error } = response\n  //     if (error) return handleError(callback.endpoint.pathname!, error.message, id)\n\n  //     if (apiCallback) {\n  //       const { init, endpoint } = apiCallback\n  //       if (endpoint.pathname === Endpoints.data.definition.put) {\n  //         assertObject(init, 'init')\n\n  //         const { body } = init\n  //         assertObject(body, 'body')\n\n  //         const putRequest: DataDefinitionPutRequest = body\n  //         const { definition: definitionObject } = putRequest\n  //         console.debug(\"handleApiCallback calling updateDefinition\", definitionObject)\n\n  //         editor.updateDefinition(definitionObject, definition)\n  //         console.debug(\"handleApiCallback called updateDefinition\")\n  //       }\n  //       if (callback.endpoint.pathname === Endpoints.rendering.status) {\n  //         const statusResponse: RenderingStatusResponse = response\n  //         let steps = 0\n  //         let step = 0\n  //         EncodeTypes.forEach(type => {\n  //           const state = statusResponse[type]\n  //           if (!state) return\n\n  //           steps += state.total\n  //           step += state.completed\n  //         })\n  //         if (steps) eventTarget.emit(EventType.Active, { \n  //           id, step, steps, type: ActivityType.Render \n  //         })\n  //       }\n        \n  //       return delayPromise().then(() => handleApiCallback(id, definition, apiCallback))\n  //     }\n  //     eventTarget.emit(EventType.Active, { id, type: ActivityType.Complete })\n  //   })\n  // }\n\n//   const handleError = (endpoint: string, error: string, id: string) => {\n//     editor.eventTarget.emit(EventType.Active, { \n//       id, type: ActivityType.Error, error: 'import.render', value: error \n//     })\n//     console.error(endpoint, error)\n//     return Promise.reject(error)\n//   }\n\n//   const saveDefinitionsPromise = (definitions: MediaArray): Promise<void> => {\n//     let promise = Promise.resolve()\n//     const { eventTarget } = editor\n// throw new Error('')\n//     // definitions.forEach(definition => {\n//     //   assertContentDefinition(definition)\n//     //   const { label, type, source } = definition\n\n//     //   const id = idGenerate('activity')\n//     //   eventTarget.emit(EventType.Active, { id, label, type: ActivityType.Render })\n\n//     //   const { rendering } = Endpoints\n//     //   console.log(\"Masher fetch\", source)\n//     //   const responsePromise = fetch(source)\n//     //   const blobPromise = responsePromise.then(response => response.blob())\n//     //   const filePromise = blobPromise.then(blob => new File([blob], label))\n//     //   const resultPromise = filePromise.then(file => {\n//     //     const request: RenderingUploadRequest = { type, name: label, size: file.size }\n//     //     console.debug(\"RenderingUploadRequest\", rendering.upload, request)\n//     //     const responsePromise = endpointPromise(rendering.upload, request)\n//     //     return responsePromise.then((response: RenderingUploadResponse) => {\n//     //       console.debug(\"RenderingUploadResponse\", rendering.upload, response)\n//     //       const { error, fileApiCallback, apiCallback, fileProperty } = response\n//     //       if (error) return handleError(rendering.upload, error, id)\n\n//     //       else if (fileApiCallback && fileApiCallback.init) {\n//     //         if (fileProperty) fileApiCallback.init.body![fileProperty] = file\n//     //         else fileApiCallback.init.body = file\n//     //         return jsonPromise(fileApiCallback).then((response: FileStoreResponse) => {\n//     //           console.debug(\"FileStoreResponse\", response)\n//     //           const { error } = response\n//     //           if (error) return handleError(fileApiCallback.endpoint.pathname!, error, id)\n    \n//     //           assertObject(apiCallback, 'apiCallback')\n//     //           return handleApiCallback(id, definition, apiCallback)\n//     //         })\n//     //       } \n//     //       assertObject(apiCallback, 'apiCallback')\n//     //       return handleApiCallback(id, definition, apiCallback)\n//     //     })\n//     //   })\n//     //   promise = promise.then(() => resultPromise)\n//     // })\n//     return promise\n//   }\n\n", "import { ClientOptions } from \"./Client\"\nimport { ClientClass } from \"./ClientClass\"\n\nexport const clientInstance = (args: ClientOptions = {}) => (\n  new ClientClass(args)\n)", "import { isPopulatedString, isString, ValueRecord, Value, isNumber } from \"@moviemasher/moviemasher.js\"\n\nexport enum Config {\n  SUPABASE_PROJECT_URL = 'MOVIEMASHER_SUPABASE_PROJECT_URL',\n  SUPABASE_ANON_KEY = 'MOVIEMASHER_SUPABASE_ANON_KEY',\n  SUPABASE_BUCKET = 'MOVIEMASHER_SUPABASE_BUCKET',\n  SUPABASE_EXPIRES = 'MOVIEMASHER_SUPABASE_EXPIRES',\n  SUPABASE_TABLE = 'MOVIEMASHER_SUPABASE_TABLE',\n}\n\nconst ConfigDefaults: ValueRecord = {\n  [Config.SUPABASE_PROJECT_URL]: '',\n  [Config.SUPABASE_BUCKET]: 'media',\n  [Config.SUPABASE_TABLE]: 'media',\n  [Config.SUPABASE_ANON_KEY]: '',\n  [Config.SUPABASE_EXPIRES]: 60,\n}\n\nexport const config = (key: Config, value?: Value): Value => {\n  if (isString(value) || isNumber(value)) ConfigDefaults[key] = value\n  return ConfigDefaults[key] || ''\n}", "import { \n  Request, LoadType, ProtocolPromise, Plugins, \n  assertTrue, isPopulatedString, \n  endpointAbsolute, \n  CssContentType, RequestInit, urlFromCss, endpointUrl, ImageType, AudioType, VideoType, FontType, HttpProtocol, HttpsProtocol, errorThrow, FontDataOrError, ProtocolType, assertEndpoint, RecordType, RecordsType, AudioDataOrError\n} from \"@moviemasher/moviemasher.js\"\nimport { audioBufferPromise } from \"../Utility/Audio\"\nimport { jsonPromise } from \"../Utility/Json\"\nimport { imageDataPromise } from \"../Utility/Image\"\nimport { videoDataPromise } from \"../Utility/Video\"\n\nconst arrayBufferPromise = (url: string, init?: RequestInit): Promise<ArrayBuffer> => (\n   fetch(url, init).then(response => response.arrayBuffer())\n)\n\nconst fontFamily = (url: string): string => url.replaceAll(/[^a-z0-9]/gi, '_')\n\nconst fontPromise =  (request: Request): Promise<FontDataOrError> => {\n  const { endpoint, init } = request\n  assertEndpoint(endpoint)\n\n  const url = endpointUrl(endpoint)\n  \n  const bufferPromise = fetch(url, init).then(response => {\n    const type = response.headers.get('content-type') || ''\n    // console.log(\"fontPromise.fetch\", type)\n    if (!isPopulatedString(type) || type.startsWith(FontType)) {\n      return response.arrayBuffer()\n    }\n    assertTrue(type.startsWith(CssContentType)) \n    \n    return response.text().then(string => {\n      // TODO: use resolverPromise instead\n      // return resolverPromise(string, type, FontType)\n      const cssUrl = urlFromCss(string)\n      // console.log(\"fontPromise.fetch CSS\", cssUrl)\n      return arrayBufferPromise(cssUrl)\n    })\n  })\n    \n  const family = fontFamily(url)\n  // console.log(\"fontPromise\", url)\n  const facePromise = bufferPromise.then(buffer => {\n    // console.log(\"fontPromise.bufferPromise\", url)\n    const face = new FontFace(family, buffer)\n    return face.load()\n  })\n  return facePromise.then(face => {\n    // console.log(\"fontPromise.facePromise\", url)\n    const { fonts } = globalThis.document\n    fonts.add(face)\n    return fonts.ready.then(() => {\n      \n      // console.log(\"fontPromise.ready\", url)\n      // this.updateLoaderFile(file, info)\n      return { data: face }\n    })\n  })\n}\n\nconst audioPromise =  (request: Request): Promise<AudioDataOrError> => {\n  const { endpoint, init } = request\n  assertEndpoint(endpoint)\n\n  const url = endpointUrl(endpoint)\n  // console.log(this.constructor.name, \"audioPromise\", isBlob ? 'BLOB' : url)\n  return arrayBufferPromise(url, init).then(audioBufferPromise)\n}\n\nconst promise: ProtocolPromise = ((request: Request, type?: LoadType) => {\n  const { endpoint, init } = request\n  assertEndpoint(endpoint)\n\n  const absolute = endpointAbsolute(endpoint)\n  const absoluteRequest = { init, endpoint: absolute }\n  // console.log('http promise', endpoint, absolute)\n  switch (type) {\n    case ImageType: return imageDataPromise(absoluteRequest)\n    case AudioType: return audioPromise(absoluteRequest)\n    case VideoType: return videoDataPromise(absoluteRequest)\n    case FontType: return fontPromise(absoluteRequest)\n    case RecordType: return jsonPromise(absoluteRequest) \n    case RecordsType: return jsonPromise(absoluteRequest)\n  }\n  errorThrow(type, 'LoadType', 'type')\n}) \n\nPlugins[ProtocolType][HttpProtocol] = { promise, type: HttpProtocol }\nPlugins[ProtocolType][HttpsProtocol] = { promise, type: HttpsProtocol }\n", "import { \n  assertEndpoint,\n  assertPopulatedString, AudibleContextInstance, AudioDataOrError, \n  endpointUrl, errorCaught, Request\n} from \"@moviemasher/moviemasher.js\"\n\nconst blobAudioPromise = (url: string): Promise<ArrayBuffer> => {\n  // console.log(this.constructor.name, \"blobAudioPromise\", url)\n\n  return fetch(url).then(response => response.blob()).then(blob => {\n    return new Promise<ArrayBuffer>((resolve, reject) => {\n      const reader = new FileReader()\n      reader.onload = () => { resolve(reader.result as ArrayBuffer) }\n      reader.onerror = reject\n      reader.readAsArrayBuffer(blob)\n    }) \n  })\n}\n\nexport const audioDataPromise = (request: Request): Promise<AudioDataOrError> => {\n  const { endpoint } = request\n  assertEndpoint(endpoint)\n\n  const url = endpointUrl(endpoint)\n  assertPopulatedString(url, 'url')\n  // console.log(this.constructor.name, \"audioPromise\", isBlob ? 'BLOB' : url)\n  const promise = blobAudioPromise(url) \n  return promise.then(audioBufferPromise)\n}\n\nexport const audioBufferPromise = (audio: ArrayBuffer): Promise<AudioDataOrError> => {\n  return AudibleContextInstance.decode(audio).then(data => ({ data }))\n    .catch(error => errorCaught(error))\n}\n\n", "import { Request, isUndefined, urlForEndpoint, assertEndpoint } from \"@moviemasher/moviemasher.js\"\n\nexport interface ResponseObject {\n  json(): Promise<any>\n\n}\nexport const jsonPromise = (request: Request): Promise<any> => {\n  return fetchPromise(request).then(response => response.json())\n}\n\nexport const fetchPromise = (request: Request): Promise<ResponseObject> => {\n  const { endpoint, init = {} } = request\n  assertEndpoint(endpoint)\n  // console.log('jsonPromise', endpoint, init)\n\n  const typeKey = 'Content-Type'\n  const jsonType = 'application/json'\n\n  const formType = 'multipart/form-data'\n\n  init.method ||= 'POST'\n  init.headers ||= {}\n  init.headers[typeKey] ||= jsonType\n  switch (init.headers[typeKey]) {\n    case jsonType: {\n      init.body = JSON.stringify(init.body)\n      break\n    }\n    case formType: {\n      const formData = new FormData()\n      Object.entries(init.body).forEach(([key, value]) => {\n        if (isUndefined(value)) return\n\n        formData.set(key, value instanceof Blob ? value : String(value))\n      })\n\n      init.body = formData\n      delete init.headers[typeKey]\n      break\n    }\n  }\n\n  const url: string = urlForEndpoint(endpoint)\n  return fetch(url, init)\n}\n", "import { \n  endpointUrl, Request, ImageData, ImageDataOrError, ErrorName, error, \n  assertEndpoint \n} from \"@moviemasher/moviemasher.js\"\n\nexport const imageDataPromise = (request: Request): Promise<ImageDataOrError> => {\n  const { endpoint } = request\n  assertEndpoint(endpoint)\n\n  const url = endpointUrl(endpoint)\n  const data = new Image()\n  data.src = url\n  return new Promise<ImageDataOrError>(resolve => {\n    data.onerror = () => {\n      resolve(error(ErrorName.Url))\n    }\n    data.onload = () => { \n      const imageData: ImageData = { data }\n      resolve(imageData) \n    }\n  })\n}\n", "import { \n  endpointUrl, ErrorName, Request, errorThrow, VideoDataOrError, errorCaught, assertEndpoint,\n} from \"@moviemasher/moviemasher.js\"\n\n\nconst videoFromUrl = (url: string): HTMLVideoElement => {\n  const { document } = globalThis\n  if (!document) errorThrow(ErrorName.Environment) \n\n  const video = document.createElement('video')\n  // video.crossOrigin = 'anonymous'\n  video.src = url\n  return video\n}\n\nexport const videoDataPromise = (request: Request): Promise<VideoDataOrError> => {\n  const { endpoint } = request\n  assertEndpoint(endpoint)\n\n  const url = endpointUrl(endpoint)\n  \n  return new Promise<VideoDataOrError>((resolve) => {\n    const clientVideo = videoFromUrl(url)\n    clientVideo.oncanplay = () => {\n      clientVideo.oncanplay = null\n      clientVideo.onerror = null\n\n      const { videoWidth, clientWidth, videoHeight, clientHeight } = clientVideo\n      const width = videoWidth || clientWidth\n      const height = videoHeight || clientHeight\n      clientVideo.width = width\n      clientVideo.height = height\n\n      // console.log(this.constructor.name, \"videoPromise.oncanplay\", width, height)\n      resolve({ data: clientVideo })\n    }\n    clientVideo.onerror = error => { resolve(errorCaught(error)) }\n    clientVideo.autoplay = false\n    // video.requestVideoFrameCallback(() => {})\n    clientVideo.load()\n  })\n}\n", "import { \n  ProtocolPromise, Plugins, Request, AudioType, ImageType, VideoType, \n  BlobProtocol, JsonType, PathData, ProtocolType\n} from \"@moviemasher/moviemasher.js\"\nimport { audioDataPromise } from \"../Utility/Audio\"\nimport { imageDataPromise } from \"../Utility/Image\"\nimport { jsonPromise } from \"../Utility/Json\"\nimport {  videoDataPromise } from \"../Utility/Video\"\n\n\n\nconst promise: ProtocolPromise = ((request: Request, type?: string) => {\n  // console.log('blob promise', url, absolute, endpoint)\n  switch (type) {\n    case AudioType: return audioDataPromise(request)\n    case ImageType: return imageDataPromise(request)\n    case VideoType: return videoDataPromise(request)\n    case JsonType: return jsonPromise(request)\n    // case FontType: return requestFontPromise(request)\n    // case FontType: return errorThrow(type, 'LoadType', 'type')//fontPromise(url)\n    default: {\n      const result: PathData = { path: '' }\n      return Promise.resolve(result)\n    }\n  }\n}) \n\n\n\nPlugins[ProtocolType][BlobProtocol] = { promise, type: BlobProtocol }\n\n", "import {\n  UnknownRecord, \n  Clip, Point, isString, Rect, isObject, isMediaType, \n  MediaType, assertMediaType, StringsRecord, NumberRecord, \n  JsonRecord, isRawType, isAboveZero, isPopulatedString, isArray, \n  DroppingPosition, isUndefined, ClassDropping, ClassDroppingAfter, \n  ClassDroppingBefore, isPopulatedObject, errorThrow, MediaObject, \n  MashAndMediaObject, MediaTypes, mediaTypeFromMime, Strings\n} from \"@moviemasher/moviemasher.js\"\n\nexport const DragSuffix = '/x-moviemasher'\n\nexport type FileInfo = File | UnknownRecord\nexport type FileInfos = FileInfo[]\n\nexport interface DragOffsetObject {\n  offset: number\n}\nexport const isDragOffsetObject = (value: any): value is DragOffsetObject => {\n  return isObject(value) && \"offset\" in value\n}\nexport function assertDragOffsetObject(value: any): asserts value is DragOffsetObject {\n  if (!isDragOffsetObject(value)) errorThrow(value, 'DragOffsetObject')\n}\n\nexport interface DragDefinitionObject extends DragOffsetObject {\n  mediaObject: UnknownRecord\n}\nexport const isDragDefinitionObject = (value: any): value is DragDefinitionObject => {\n  return isDragOffsetObject(value) && \"mediaObject\" in value && isObject(value.mediaObject)\n}\nexport function assertDragDefinitionObject(value: any): asserts value is DragDefinitionObject {\n  if (!isDragDefinitionObject(value)) errorThrow(value, 'DragDefinitionObject')\n}\n\nexport interface DragLayerObject extends UnknownRecord {\n  offset: number\n  mashAndMedia?: MashAndMediaObject\n}\n\n\nexport type Draggable = MediaObject | MashAndMediaObject | Clip | FileList\n\n\nexport const TransferTypeFiles = \"Files\"\nexport type TransferType = string \nexport const isTransferType = (value: any): value is TransferType => {\n  return isString(value) && value.endsWith(DragSuffix)\n}\n// \nexport const dropType = (dataTransfer?: DataTransfer | null): TransferType | undefined => {\n  if (!dataTransfer) return\n  \n  return dataTransfer.types.find(isTransferType)\n}\n\nexport const dragMediaType = (transferType: TransferType): MediaType => {\n  const [type] = transferType.split('/')\n  assertMediaType(type)\n  return type\n}\n\nexport const dragType = (dataTransfer?: DataTransfer | null): MediaType | undefined => {\n  const prefix = dropType(dataTransfer)\n  if (!prefix) return\n\n  const [type] = prefix.split('/')\n  if (isMediaType(type)) return type\n}\n\nexport const dragTypes = (dataTransfer: DataTransfer): Strings => {\n  const { types } = dataTransfer\n  return types.filter(type => (\n    type === TransferTypeFiles || isTransferType(type)\n  ))\n}\n\nexport const dragData = (dataTransfer: DataTransfer, type?: TransferType) => {\n  const transferType = type ? `${type}${DragSuffix}` : dragTypes(dataTransfer).find(isTransferType)\n  if (!transferType) return {}\n\n  const json = dataTransfer.getData(transferType)\n  // console.log(\"dragData\", json, type, transferType)\n  const data = json ? JSON.parse(json) : {}\n  return data\n}\n\nexport const DragElementRect = (current: Element): Rect => current.getBoundingClientRect()\n\nexport const DragElementPoint = (event: DragEvent, current: Element | Rect,): Point => {\n  const rect = (current instanceof Element) ? DragElementRect(current) : current\n  const { x, y } = rect\n  const { clientY, clientX } = event\n  return { x: clientX - x, y: clientY - y }\n}\n\nexport const dropFilesFromList = (files: FileList, serverOptions: JsonRecord = {}): FileInfos => {\n  const infos: FileInfos = []\n  const { length } = files\n  if (!length) return infos\n\n  const exists = isPopulatedObject(serverOptions)\n  const { extensions = {}, uploadLimits = {} } = serverOptions\n  const extensionsByType = extensions as StringsRecord\n  const limitsByType = uploadLimits as NumberRecord\n\n  for (let i = 0; i < length; i++) {\n    const file = files.item(i)\n    if (!file) continue\n\n    const { name, size, type } = file\n    const coreType = mediaTypeFromMime(type) \n    if (!isRawType(coreType)) {\n      infos.push({ label: name, value: coreType, error: 'import.type' })\n      continue\n    }\n    \n    const max = limitsByType[coreType]\n    if (exists && !(isAboveZero(max) && max * 1024 * 1024 > size)) {\n      infos.push({ label: name, value: `${max}MB`, error: 'import.bytes' })\n      continue\n    }\n\n    const ext = name.toLowerCase().split('.').pop()\n    const extDefined = isPopulatedString(ext)\n    const exts = extensionsByType[coreType]\n    if (exists || !extDefined) {\n      if (!(extDefined && isArray(exts) && exts.includes(ext))) {\n        infos.push({ label: name, value: ext, error: 'import.extension' })\n        continue\n      } \n    }\n    infos.push(file)\n  }\n  console.log('dropFilesFromList infos', infos)\n  return infos\n}\n\n\nexport const droppingPositionClass = (droppingPosition?: DroppingPosition | number): string => {\n  if (isUndefined(droppingPosition)) return ''\n\n  switch (droppingPosition) {\n    case DroppingPosition.After: return ClassDroppingAfter\n    case DroppingPosition.Before: return ClassDroppingBefore\n    case DroppingPosition.None: return ''\n  }\n  return ClassDropping\n}\n", "import { roundWithMethod } from \"@moviemasher/moviemasher.js\"\n\nexport const pixelPerFrame = (frames: number, width: number, zoom = 1): number => {\n  if (!(frames && width)) return 0\n\n  const widthFrames = width / frames\n\n  const min = Math.min(1, widthFrames)\n  const max = Math.max(1, widthFrames)\n  if (zoom === 1) return max\n  if (!zoom) return min\n\n  return min + ((max - min) * zoom)\n}\n\nexport const pixelFromFrame = (frame: number, perFrame : number, rounding = 'ceil'): number => {\n  if (!(frame && perFrame)) return 0\n\n  const pixels = frame * perFrame\n  return roundWithMethod(pixels, rounding)\n}\n", "import { Identified } from \"@moviemasher/moviemasher.js\"\n\n\n\nexport enum ActivityType {\n  Analyze = 'analyze',\n  Complete = 'complete',\n  Error = \"error\",\n  Load = 'load',\n  Render = 'render',\n}\n\nexport interface ActivityInfo extends Identified {\n  type: ActivityType\n  label?: string\n  steps?: number\n  step?: number\n  error?: string\n  value?: string\n}\n"],
  "mappings": "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",
  "names": ["AlphaProbe", "AudibleProbe", "AudioType", "DurationProbe", "Endpoints", "ImageType", "MashType", "OrderDecending", "ProbeType", "RawTypes", "SizeProbe", "VideoType", "ReadOperation", "WriteOperation", "TranscodeOperation", "EncodeOperation", "DecodeOperation", "Operations", "isOperation", "value", "ClientDisabledArgs", "ClientDefaultArgs", "type", "assertIdentified", "isMashMedia", "requestRecordPromise", "transcodingInstance", "VideoType", "ErrorName", "error", "idIsTemporary", "assertPopulatedString", "isMedia", "isVideoMedia", "isImageMedia", "isUpdatableDurationDefinition", "ProbeType", "isArray", "ClientClass", "options", "args", "write", "accept", "isArray", "operation", "isOperation", "Operations", "media", "isMashMedia", "steps", "response", "clientOptions", "ClientDefaultArgs", "mash", "temporaryMedia", "idIsTemporary", "id", "result", "code", "ErrorName", "error", "type", "WriteOperation", "saveRequest", "requestObject", "request", "requestRecordPromise", "assertIdentified", "mediaObject", "newId", "assertPopulatedString", "target", "oldId", "idChanged", "isMedia", "isVideoMedia", "isUpdatableDurationDefinition", "isImageMedia", "tracks", "track", "clip", "mediaArray", "promise", "ProbeType", "mashMedia", "transcoding", "transcodingInstance", "VideoType", "clientInstance", "args", "ClientClass", "isString", "isNumber", "Config", "ConfigDefaults", "config", "key", "value", "Plugins", "assertTrue", "isPopulatedString", "endpointAbsolute", "CssContentType", "urlFromCss", "endpointUrl", "ImageType", "AudioType", "VideoType", "FontType", "HttpProtocol", "HttpsProtocol", "errorThrow", "ProtocolType", "assertEndpoint", "RecordType", "RecordsType", "assertEndpoint", "assertPopulatedString", "AudibleContextInstance", "endpointUrl", "errorCaught", "blobAudioPromise", "url", "response", "blob", "resolve", "reject", "reader", "audioDataPromise", "request", "endpoint", "audioBufferPromise", "audio", "data", "error", "isUndefined", "urlForEndpoint", "assertEndpoint", "jsonPromise", "request", "fetchPromise", "response", "endpoint", "init", "typeKey", "jsonType", "formType", "formData", "key", "value", "url", "endpointUrl", "ErrorName", "error", "assertEndpoint", "imageDataPromise", "request", "endpoint", "url", "data", "resolve", "endpointUrl", "ErrorName", "errorThrow", "errorCaught", "assertEndpoint", "videoFromUrl", "url", "document", "video", "videoDataPromise", "request", "endpoint", "resolve", "clientVideo", "videoWidth", "clientWidth", "videoHeight", "clientHeight", "width", "height", "error", "arrayBufferPromise", "url", "init", "response", "fontFamily", "fontPromise", "request", "endpoint", "assertEndpoint", "endpointUrl", "bufferPromise", "type", "isPopulatedString", "FontType", "assertTrue", "CssContentType", "string", "cssUrl", "urlFromCss", "family", "buffer", "face", "fonts", "audioPromise", "audioBufferPromise", "promise", "absolute", "endpointAbsolute", "absoluteRequest", "ImageType", "imageDataPromise", "AudioType", "VideoType", "videoDataPromise", "RecordType", "jsonPromise", "RecordsType", "errorThrow", "Plugins", "ProtocolType", "HttpProtocol", "HttpsProtocol", "Plugins", "AudioType", "ImageType", "VideoType", "BlobProtocol", "JsonType", "ProtocolType", "promise", "request", "type", "AudioType", "audioDataPromise", "ImageType", "imageDataPromise", "VideoType", "videoDataPromise", "JsonType", "jsonPromise", "result", "Plugins", "ProtocolType", "BlobProtocol", "isString", "isObject", "isMediaType", "assertMediaType", "isRawType", "isAboveZero", "isPopulatedString", "isArray", "DroppingPosition", "isUndefined", "ClassDropping", "ClassDroppingAfter", "ClassDroppingBefore", "isPopulatedObject", "errorThrow", "mediaTypeFromMime", "DragSuffix", "isDragOffsetObject", "value", "assertDragOffsetObject", "isDragDefinitionObject", "assertDragDefinitionObject", "TransferTypeFiles", "isTransferType", "dropType", "dataTransfer", "dragMediaType", "transferType", "type", "dragType", "prefix", "dragTypes", "types", "dragData", "json", "DragElementRect", "current", "DragElementPoint", "event", "rect", "x", "y", "clientY", "clientX", "dropFilesFromList", "files", "serverOptions", "infos", "length", "exists", "extensions", "uploadLimits", "extensionsByType", "limitsByType", "i", "file", "name", "size", "coreType", "max", "ext", "extDefined", "exts", "droppingPositionClass", "droppingPosition", "roundWithMethod", "pixelPerFrame", "frames", "width", "zoom", "widthFrames", "min", "max", "pixelFromFrame", "frame", "perFrame", "rounding", "pixels", "ActivityType"]
}
