{
  "version": 3,
  "sources": ["../src/Client/Client.ts", "../src/Client/ClientClass.ts", "../src/Client/ClientFactory.ts", "../src/Config/Config.ts", "../src/Protocol/Http.ts", "../src/Utility/Audio.ts", "../src/Utility/Json.ts", "../src/Utility/Image.ts", "../src/Utility/Video.ts", "../src/Protocol/Blob.ts", "../src/Utility/DragDrop.ts", "../src/Utility/Pixel.ts", "../src/Utility/Activity.ts"],
  "sourcesContent": ["import { \n  AlphaProbe, AudibleProbe, AudioType, CookedTypes, DecodeOutput, Decoding, \n  DurationProbe, Encoding, Endpoints, ImageType, LoadType, MashMedia, MashType, \n  Media, MediaType, MediaTypes, OrderDecending, PotentialError, ProbeType, \n  RawTypes, Request, SizeProbe, StringRecord, Strings, TranscodeOutput, \n  Transcoding, VideoType \n} from \"@moviemasher/moviemasher.js\"\n\nexport interface DecodeTypesByMediaType extends Record<LoadType, DecodeOutput[]> {}\nexport interface TranscodingTypesByMediaType extends Record<LoadType, TranscodeOutput[]> {}\n\n\nexport type ReadOperation = 'read'\nexport type WriteOperation = 'write'\nexport type TranscodeOperation = 'transcode'\nexport type EncodeOperation = 'encode'\nexport type DecodeOperation = 'decode'\nexport const ReadOperation: ReadOperation = 'read'\nexport const WriteOperation: WriteOperation = 'write'\nexport const TranscodeOperation: TranscodeOperation = 'transcode'\nexport const EncodeOperation: EncodeOperation = 'encode'\nexport const DecodeOperation: DecodeOperation = 'decode'\n\nexport type Operation = ReadOperation | WriteOperation | TranscodeOperation | EncodeOperation | DecodeOperation\nexport type Operations = Operation[]\nexport const Operations: Operations = [ReadOperation, WriteOperation, TranscodeOperation, EncodeOperation, DecodeOperation]\nexport const isOperation = (value: any): value is Operation => {\n  return Operations.includes(value)\n}\n\n\nexport interface Client {\n  accept(options?: ClientSaveOptions): string | undefined\n  enabled(operation?: Operation): boolean\n  decode(options: ClientDecodeOptions): Promise<Decoding>\n  encode(mashMedia: MashMedia, options?: ClientEncodeOptions): Promise<Encoding>\n  list(options?: ClientReadOptions): Promise<ClientArrayResponse>\n  get(options?: ClientReadOptions): Promise<ClientObjectResponse>\n\n  save(media: Media, options?: ClientSaveOptions): Promise<ClientObjectResponse>\n  transcode(options: ClientTranscodeOptions): Promise<Transcoding>\n}\n\n\nexport interface ClientDecodeOptions { \n  autoDecode?: DecodeTypesByMediaType | false\n}\n\nexport interface ClientEncodeOptions {\n  autoTranscode?: TranscodingTypesByMediaType | false\n}\n\nexport interface ClientTranscodeOptions {\n  autoTranscode?: TranscodingTypesByMediaType | false\n}\nexport interface ClientReadParams {\n  type?: MediaType | MediaTypes\n  kind?: string | Strings\n  order?: string | StringRecord\n}\nexport interface ClientReadOptions extends ClientReadParams {\n  autoGet?: ClientReadParams | false\n  getRequest?: Request | false\n  listRequest?: Request | false\n}\n\nexport interface ClientArgs extends Required<ClientOptions> {}\n\nexport interface ClientWriteOptions {\n  accept?: string | Strings \n  saveRequest?: Request | false\n  deleteRequest?: Request | false\n  uploadRequest?: Request | false\n  uploadResponseIsRequest?: boolean\n  uploadCookedTypes?: CookedTypes\n}\n\nexport interface ClientOptions {\n  [ReadOperation]?: ClientReadOptions | false | undefined\n  [WriteOperation]?: ClientWriteOptions | false | undefined\n  [DecodeOperation]?: ClientDecodeOptions | false | undefined\n  [EncodeOperation]?: ClientEncodeOptions | false | undefined\n  [TranscodeOperation]?: ClientTranscodeOptions | false | undefined\n} \n\n\nexport const ClientDisabledArgs: ClientArgs = {\n  [ReadOperation]: false,\n  [WriteOperation]: false,\n  [DecodeOperation]: false,\n  [EncodeOperation]: false,\n  [TranscodeOperation]: false,\n}\n\nexport const ClientDefaultArgs: ClientArgs = {\n  [DecodeOperation]: {\n    autoDecode: {\n      [AudioType]: [{ \n        type: ProbeType, \n        options: { types: [DurationProbe] }\n      }],\n      [ImageType]: [{ \n        type: ProbeType, \n        options: { types: [AlphaProbe, SizeProbe] }\n      }],\n\n      [VideoType]: [{ \n        type: ProbeType, \n        options: { \n          types: [\n            DurationProbe, SizeProbe, \n            AlphaProbe, AudibleProbe \n          ] \n        }\n      }],\n    },\n  },\n  [EncodeOperation]: {\n\n  },\n  [ReadOperation]: {\n    autoGet: { type: MashType, order: { created_at: OrderDecending }},\n    getRequest: { endpoint: { pathname: Endpoints.data.definition.get } }, \n    listRequest: { endpoint: { pathname: Endpoints.data.definition.retrieve } },\n      \n  },\n  [TranscodeOperation]: {\n    autoTranscode: {\n      [AudioType]: [\n        { \n          type: AudioType, \n          options: { outputType: AudioType } \n        }\n      ],\n    },\n  },\n  [WriteOperation]: {\n    accept: RawTypes.map(type => `${type}/*`),\n    saveRequest: { endpoint: { pathname: Endpoints.data.definition.put} }, \n    deleteRequest: { endpoint: { pathname: Endpoints.data.definition.delete } }, \n    uploadRequest: { endpoint: { pathname: Endpoints.data.definition.retrieve } },\n    uploadResponseIsRequest: true,\n    uploadCookedTypes: [],\n  },\n}\n\nexport interface ClientSaveOptions extends ClientOptions {\n  callback?: ClientCallback\n}\n\nexport interface ClientProgress extends PotentialError {\n  mash?: MashMedia\n  media: Media\n  processing?: Transcoding | Encoding | Decoding\n  completed: number\n}\n\nexport interface ClientProgessSteps extends ClientProgress {\n  steps: number\n  step: number\n}\n\nexport type ClientCallback = (progress: ClientProgress) => void\n\n\nexport interface ClientArrayResponse extends PotentialError {\n  data?: Media[]\n}\nexport interface ClientObjectResponse extends PotentialError {\n  data?: Media\n}\n\nexport type ClientSaveResponse = ClientArrayResponse | ClientObjectResponse\n\n\n\n", "import { \n  assertIdentified, DataDefinitionPutRequest, DataDefinitionPutResponse, \n  Decoding, Encoding, isMashMedia, MashMedia, Media, MediaObject, MediaArray, \n  requestRecordPromise, Transcoding, transcodingInstance, VideoType, \n  Request, ErrorName, error, idIsTemporary, assertPopulatedString, isMedia, \n  isVideoMedia, isImageMedia, isUpdatableDurationDefinition, \n  PotentialError, ProbeType, isArray, \n} from \"@moviemasher/moviemasher.js\"\n\nimport { \n  Client, ClientOptions, ClientDecodeOptions, ClientEncodeOptions, \n  ClientReadOptions, ClientSaveOptions, ClientTranscodeOptions, \n  ClientObjectResponse, ClientProgessSteps, ClientArrayResponse, \n  ClientDefaultArgs, ClientArgs, Operation, isOperation, Operations, WriteOperation} from \"./Client\"\n\n\nexport class ClientClass implements Client {\n  constructor(public options?: ClientOptions) {}\n\n  accept(options?: ClientSaveOptions): string | undefined { \n    const args = this.clientArgs(options)\n    const { write } = args\n    if (!write) return \n\n    const { accept } = write\n    return isArray(accept) ? accept.join(',') : accept\n  }\n\n\n  enabled(operation?: Operation): boolean {\n    const operations = isOperation(operation) ? [operation] : Operations\n    return operations.every(operation => {\n\n    })\n  }\n\n  get(options?: ClientReadOptions | undefined): Promise<ClientObjectResponse> {\n       throw new Error(\"Method not implemented.\")\n \n  }\n  list(args: ClientReadOptions): Promise<ClientArrayResponse> {\n    throw new Error(\"Method not implemented.\")\n  }\n  save(media: Media, options?: ClientSaveOptions): Promise<ClientObjectResponse> {\n    const args = this.clientArgs(options)\n\n    if (isMashMedia(media)) return this.saveMash(media, args) \n    \n    const steps: ClientProgessSteps = {\n      step: 0, steps: 2, media, completed: 0\n    }\n    this.saveMedia(media, steps, args)\n    \n    const response: ClientObjectResponse = {}\n    return Promise.resolve(response)\n  }\n\n  private clientArgs(clientOptions: ClientOptions = {}): ClientArgs {\n    const { options = {}} = this\n    return { ...ClientDefaultArgs, ...options, ...clientOptions }\n  }\n  \n  protected saveMash(mash: MashMedia, args: ClientArgs): Promise<ClientObjectResponse> {\n    const temporaryIds = mash.definitionIds.filter(idIsTemporary)\n    const temporaryMedia = temporaryIds.map(id => mash.media.fromId(id))\n\n    const steps: ClientProgessSteps = {\n      step: 0, steps: 1, mash, media: mash, completed: 0\n    }\n    \n    return this.saveMedias(temporaryMedia, steps, args).then(result => \n      result.error ? result : this.saveMediaRow(mash, steps, args)\n    )\n  }\n    // const definitionsPromise = saveDefinitionsPromise(definitionsUnsaved)\n    // const requestPromise = definitionsPromise.then(() => editor.dataPutRequest())\n    // const savePromise = requestPromise.then(request => {\n    //   // const { editType } = editor\n    //   console.debug(\"DataPutRequest\", Endpoints.data[editType].put, JSON.parse(JSON.stringify(request)))\n    //   endpointPromise(Endpoints.data[editType].put, request).then((response: DataPutResponse) => {\n    //     console.debug(\"DataPutResponse\", Endpoints.data[editType].put, response)\n    //     const { error, temporaryIdLookup } = response\n    //     if (error) console.error(Endpoints.data[editType].put, error)\n    //     else editor.saved(temporaryIdLookup)\n    //   })\n    // })\n\n\n  // dataPutRequest(): Promise<DataPutRequest> {\n  //   const { mashMedia, editType } = this\n  //   assertObject(mashMedia, 'edited')\n  //   assertEditType(editType)\n\n  //   // set edit's label if it's empty\n  //   const { label } = mashMedia \n  //   if (!isPopulatedString(label)) {\n  //     const defaultLabel = Default[editType].label\n  //     assertPopulatedString(defaultLabel, 'defaultLabel')\n  //     mashMedia.setValue(defaultLabel, 'label')\n  //   }\n  \n  //   return mashMedia.putPromise().then(() => {\n  //     if (isMashMedia(mashMedia)) {\n  //       return {\n  //         mash: mashMedia.toJSON(),\n  //         definitionIds: mashMedia.definitionIds\n  //       }\n  //     } \n  //   })\n  // }\n\n\n  private errorPromise(code: ErrorName = ErrorName.Internal): Promise<PotentialError> {\n    return Promise.resolve(error(code))\n  }\n  protected saveMediaRow(media: Media, steps: ClientProgessSteps, args: ClientArgs): Promise<ClientObjectResponse> {\n    const { id, type } = media\n    const options = args[WriteOperation]\n    if (!options) return this.errorPromise()\n\n    const { saveRequest } = options\n    if (!saveRequest) return this.errorPromise()\n\n\n    const requestObject: Request = { ...saveRequest }\n    requestObject.init ||= {}\n    const definition: MediaObject = { id, ...media.toJSON() }\n    const request: DataDefinitionPutRequest = { definition }\n    requestObject.init.body = request\n    return requestRecordPromise(requestObject).then(result => {\n      assertIdentified(result)\n      const { id, error } = result as DataDefinitionPutResponse\n      steps.step++\n      const response: ClientObjectResponse = { error, data: media }\n      return response\n    })\n  }\n\n  protected saveAutoDecodings(media: Media, steps: ClientProgessSteps, args: ClientArgs): Promise<ClientObjectResponse> {\n    return Promise.resolve(error(ErrorName.ClientDisabledDelete))\n\n  }\n\n\n  \n  protected upload(media: Media, steps: ClientProgessSteps, args: ClientArgs): Promise<ClientObjectResponse> {\n    return Promise.resolve(error(ErrorName.ClientDisabledDelete))\n    //   const { uploadResponseIsRequest, uploadCookedTypes } = args\n\n  //   if (uploadResponseIsRequest) {\n\n  //   }\n\n  //   const { label, type, clientMedia } = media\n  //   if (!clientMedia) return Promise.resolve(error(ErrorName.Internal))\n  \n  //   if (isRawType(type)) {\n  //     type\n  //   }\n  //   switch (type) {\n  //     case AudioType:\n  //     case ImageType:\n  //     case VideoType:\n        \n  //       break;\n    \n  //     default:\n  //       break;\n  //   }\n\n\n  //   const id = idGenerate('activity')\n  \n  //   const { rendering } = Endpoints\n  //   console.log(\"Masher fetch\", source)\n  //   const responsePromise = fetch(source)\n  //   const blobPromise = responsePromise.then(response => response.blob())\n  //   const filePromise = blobPromise.then(blob => new File([blob], label))\n  //   const resultPromise = filePromise.then(file => {\n  //     const request: RenderingUploadRequest = { type, name: label, size: file.size }\n  //     console.debug(\"RenderingUploadRequest\", rendering.upload, request)\n  //     const responsePromise = endpointPromise(rendering.upload, request)\n  //     return responsePromise.then((response: RenderingUploadResponse) => {\n  //       console.debug(\"RenderingUploadResponse\", rendering.upload, response)\n  //       const { error, fileApiCallback, apiCallback, fileProperty } = response\n  //       if (error) return handleError(rendering.upload, error, id)\n  \n  //       else if (fileApiCallback && fileApiCallback.init) {\n  //         if (fileProperty) fileApiCallback.init.body![fileProperty] = file\n  //         else fileApiCallback.init.body = file\n  //         return jsonPromise(fileApiCallback).then((response: FileStoreResponse) => {\n  //           console.debug(\"FileStoreResponse\", response)\n  //           const { error } = response\n  //           if (error) return handleError(fileApiCallback.endpoint.pathname!, error, id)\n  \n  //           assertObject(apiCallback, 'apiCallback')\n  //           return handleApiCallback(id, definition, apiCallback)\n  //         })\n  //       } \n  //       assertObject(apiCallback, 'apiCallback')\n  //       return handleApiCallback(id, definition, apiCallback)\n  //     })\n  //  })\n  }\n  protected saveUpload(media: Media, steps: ClientProgessSteps, args: ClientArgs): Promise<ClientObjectResponse> {\n    const { id } = media\n    if (idIsTemporary(id)) return this.upload(media, steps, args)\n\n    return this.saveMediaRow(media, steps, args)\n  }\n\n  protected saveAutoTranscodings(media: Media, steps: ClientProgessSteps, args: ClientArgs): Promise<ClientObjectResponse> {\n    return Promise.resolve(error(ErrorName.ClientDisabledDelete))\n\n  }\n\n  \n  protected saveMedia(media: Media, steps: ClientProgessSteps, args: ClientArgs): Promise<ClientObjectResponse> {\n    return Promise.resolve(error(ErrorName.ClientDisabledDelete))\n\n    // steps.media = media\n    // const { autoDecode, autoTranscode } = args\n\n    // const { id, type, transcodings, decodings } = media\n    // return this.saveUpload(media, steps, args).then(result => (\n    //   result.error ? result : this.saveAutoDecodings(media, steps, args)\n    // ))\n\n    // if (!decodings.length && autoDecode && autoDecode[type])\n\n    // return this.saveMediaRow(media, steps, args)\n\n    \n  }\n\n\n  private updateMedia(mediaObject: MediaObject, mash: MashMedia, media?: Media): Promise<void> {\n    \n    const {id: newId } = mediaObject\n    const id = mediaObject.id || media!.id\n    assertPopulatedString(id)\n\n    const target = media || mash.media.fromId(newId!)\n    const { id: oldId } = target\n    const idChanged = oldId !== id\n    console.log(this.constructor.name, \"updateDefinition\", idChanged, mediaObject)\n    if (idChanged) {\n      mash.media.updateDefinitionId(target.id, id)\n      console.log(this.constructor.name, \"updateDefinition called updateDefinitionId\", target.id, id)\n\n      // TODO - replace assign\n      Object.assign(target, mediaObject)\n      \n      if (isMedia(target)) {\n        delete target.file\n        delete target.request.response \n        if (isVideoMedia(target)) {\n          delete target.loadedVideo \n        }\n        else if (isUpdatableDurationDefinition(target)) delete target.loadedAudio \n        else if (isImageMedia(target)) delete target.loadedImage \n      }    \n    } \n    if (!idChanged) return Promise.resolve()\n    \n    const { tracks } = mash\n    const clips = tracks.flatMap(track => track.clips)\n    clips.forEach(clip => {\n      if (clip.containerId === oldId) clip.setValue(newId, 'containerId')\n      if (clip.contentId === oldId) clip.setValue(newId, 'contentId')\n    })\n    return mash.reload() || Promise.resolve()\n  }\n\n  protected saveMedias(mediaArray: MediaArray, steps: ClientProgessSteps, args: ClientArgs): Promise<ClientObjectResponse> {\n    let promise: Promise<ClientObjectResponse> = Promise.resolve({})\n    mediaArray.forEach(media => {\n      promise = promise.then(result => (\n        result.error ? result : this.saveMedia(media, steps, args)\n      ))\n    })\n\n    return promise\n  }\n\n  decode(args: ClientDecodeOptions): Promise<Decoding> {\n    return Promise.resolve({ type: ProbeType })\n  }\n\n  encode(mashMedia: MashMedia, args: ClientEncodeOptions): Promise<Encoding> {\n    throw new Error(\"Method not implemented.\")\n\n    // const media = editor.definitions.map(object => object.toJSON()) as MediaObjects\n    // const mashObject = mashMedia.toJSON() as MashMediaObject\n    // const mash: MashAndMediaObject = { ...mashObject, media }\n    // const request: RenderingStartRequest = {\n    //   mash,\n    //   output: {outputType: VideoType},\n    // }\n    // console.debug(\"RenderingStartRequest\", Endpoints.rendering.start, request)\n    // endpointPromise(Endpoints.rendering.start, request).then((response: RenderingStartResponse) => {\n    //   console.debug(\"RenderingStartResponse\", Endpoints.rendering.start, response)\n    //   const { apiCallback, error } = response\n    //   if (error) handleError(Endpoints.rendering.start, request, response, error.message)\n    //   else handleApiCallback(apiCallback!, mashMedia)\n    // })\n\n\n  }\n\n  transcode(args: ClientTranscodeOptions): Promise<Transcoding> {\n    const transcodingobject = { type: VideoType, id: '', request: { endpoint: {}}}\n    const transcoding = transcodingInstance(transcodingobject)\n    return Promise.resolve(transcoding)\n\n  }\n}\n\n\n// let promise = Promise.resolve()\n\n// definitions.forEach(definition => {\n//   assertContentDefinition(definition)\n//   const { label, type, source } = definition\n\n//   const id = idGenerate('activity')\n//   eventTarget.emit(EventType.Active, { id, label, type: ActivityType.Render })\n\n//   const { rendering } = Endpoints\n//   console.log(\"Masher fetch\", source)\n//   const responsePromise = fetch(source)\n//   const blobPromise = responsePromise.then(response => response.blob())\n//   const filePromise = blobPromise.then(blob => new File([blob], label))\n//   const resultPromise = filePromise.then(file => {\n//     const request: RenderingUploadRequest = { type, name: label, size: file.size }\n//     console.debug(\"RenderingUploadRequest\", rendering.upload, request)\n//     const responsePromise = endpointPromise(rendering.upload, request)\n//     return responsePromise.then((response: RenderingUploadResponse) => {\n//       console.debug(\"RenderingUploadResponse\", rendering.upload, response)\n//       const { error, fileApiCallback, apiCallback, fileProperty } = response\n//       if (error) return handleError(rendering.upload, error, id)\n\n//       else if (fileApiCallback && fileApiCallback.init) {\n//         if (fileProperty) fileApiCallback.init.body![fileProperty] = file\n//         else fileApiCallback.init.body = file\n//         return jsonPromise(fileApiCallback).then((response: FileStoreResponse) => {\n//           console.debug(\"FileStoreResponse\", response)\n//           const { error } = response\n//           if (error) return handleError(fileApiCallback.endpoint.pathname!, error, id)\n\n//           assertObject(apiCallback, 'apiCallback')\n//           return handleApiCallback(id, definition, apiCallback)\n//         })\n//       } \n//       assertObject(apiCallback, 'apiCallback')\n//       return handleApiCallback(id, definition, apiCallback)\n//     })\n//   })\n//   promise = promise.then(() => resultPromise)\n// })\n\n\n\n// from rendering server class \n\n  // private populateDefinition(user: string, renderingId: string, definition: MediaObject, commandOutputs: RenderingCommandOutputs): void {\n  //   const { fileServer } = this\n  //   assertTrue(fileServer)\n\n  //   const { id, source, type: definitionType } = definition\n  //   assertPopulatedString(id)\n  //   assertMediaType(definitionType)\n  //   assertPopulatedString(source)\n\n  //   const prefix = path.join(fileServer.userUploadPrefix(id, user), renderingId)\n  //   const outputDirectory = this.outputDirectory(user, id)\n  //   const inInfoName = `upload.${ExtensionLoadedInfo}`\n  //   const inInfoPath = path.join(outputDirectory, renderingId, inInfoName)\n  //   const inInfoExists = fs.existsSync(inInfoPath)\n  //   const inInfo: ProbingData = inInfoExists ? expandToJson(inInfoPath) : {}\n  //   const { \n  //     width: inWidth, height: inHeight,\n  //     duration: inDuration, audible: inAudible, label: inLabel\n  //   } = inInfo\n  //   if (isUpdatableDurationType(definitionType) && isAboveZero(inDuration)) {\n  //     definition.duration = inDuration\n  //   }\n  //   if (isUpdatableSizeType(definitionType)) {\n  //     if (isAboveZero(inWidth) && isAboveZero(inHeight)) {\n  //       definition.sourceSize = { width: inWidth, height: inHeight }\n  //     }\n  //   }\n  //   const countByType: NumberRecord = {}\n  //   commandOutputs.forEach(output => {\n  //     const { outputType } = output\n  //     if (!isDefined(countByType[outputType])) countByType[outputType] = -1\n  //     countByType[outputType]++\n  //     const index = countByType[outputType]\n  //     const outInfoName = renderingOutputFile(index, output, ExtensionLoadedInfo)\n  //     const outInfoPath = path.join(outputDirectory, renderingId, outInfoName)\n\n  //     const outInfo: ProbingData = expandToJson(outInfoPath)\n  //     const { \n  //       width: outWidth, height: outHeight, \n  //       duration: outDuration, audible: outAudible, extension\n  //     } = outInfo\n  //     const outputFilename = renderingOutputFile(index, output, extension)\n  //     const outUrl = path.join(prefix, outputFilename)\n  //     // console.log(this.constructor.name, \"populateDefinition\", outInfo, index, outputType, outUrl)\n  //     switch(outputType) {\n  //       // case EncodeType.ImageSequence: {\n  //       //   if (isAboveZero(outWidth) && isAboveZero(outHeight)) {\n  //       //     definition.fps = output.videoRate\n  //       //     definition.previewSize = { width: outWidth, height: outHeight }\n  //       //     definition.url = prefix + '/'\n  //       //   } \n  //       //   break\n  //       // }\n  //       case EncodeType.Audio: {\n  //         const { duration: definitionDuration } = definition\n  //         if (isAboveZero(outDuration) && isAboveZero(definitionDuration)) {\n  //           definition.audio = true\n  //           definition.duration = Math.min(definitionDuration, outDuration)\n  //           const audioInput = definitionType === AudioType\n  //           if (audioInput) definition.url = outUrl\n  //           else definition.audioUrl = outUrl\n  //         }\n  //         break\n  //       }\n  //       case EncodeType.Image: {\n  //         if (isAboveZero(outWidth) && isAboveZero(outHeight)) {\n  //           const outSize = { width: outWidth, height: outHeight }\n  //           const imageInput = definitionType === ImageType\n  //           if (imageInput && !index) {\n  //             definition.previewSize = outSize\n  //             definition.url = outUrl\n  //           } else definition.icon = outUrl\n  //         }\n  //         break\n  //       }\n  //     }\n  //   })\n  //   // console.log(this.constructor.name, \"populateDefinition\", definition)\n  // }\n  // private _renderingCommandOutputs?: UnusedRenderingCommandOutputs\n  // private get renderingCommandOutputs(): UnusedRenderingCommandOutputs {\n  //   if (this._renderingCommandOutputs) return this._renderingCommandOutputs\n\n  //   const { previewSize, outputSize } = this\n  //   const provided = this.args.commandOutputs || {}\n  //   const outputs = Object.fromEntries(EncodeTypes.map(outputType => {\n  //     const base: RenderingCommandOutput = { outputType }\n  //     switch (outputType) {\n  //       case EncodeType.Image: {\n  //         base.width = previewSize.width\n  //         base.height = previewSize.height\n  //         base.cover = true\n  //         break\n  //       }\n  //       case EncodeType.Video: {\n  //         base.width = outputSize.width\n  //         base.height = outputSize.height\n  //         break\n  //       }\n  //     }\n  //     const commandOutput: CommandOutput = provided[outputType] || {}\n  //     const renderingCommandOutput: RenderingCommandOutput = { ...base, ...commandOutput }\n  //     return [outputType, renderingCommandOutput]\n  //   }))\n  //   return this._renderingCommandOutputs = outputs\n  // }\n\n\n  // FROM Masher.tsx\n\n    // const handleApiCallback = (id: string, definition: Media, callback: ApiCallback): Promise<void> => {\n  //   console.debug(\"handleApiCallback request\", callback)\n  //   const { eventTarget } = editor\n  //   return jsonPromise(callback).then((response: ApiCallbackResponse) => {\n  //     console.debug(\"handleApiCallback response\", response)\n  //     const { apiCallback, error } = response\n  //     if (error) return handleError(callback.endpoint.pathname!, error.message, id)\n\n  //     if (apiCallback) {\n  //       const { init, endpoint } = apiCallback\n  //       if (endpoint.pathname === Endpoints.data.definition.put) {\n  //         assertObject(init, 'init')\n\n  //         const { body } = init\n  //         assertObject(body, 'body')\n\n  //         const putRequest: DataDefinitionPutRequest = body\n  //         const { definition: definitionObject } = putRequest\n  //         console.debug(\"handleApiCallback calling updateDefinition\", definitionObject)\n\n  //         editor.updateDefinition(definitionObject, definition)\n  //         console.debug(\"handleApiCallback called updateDefinition\")\n  //       }\n  //       if (callback.endpoint.pathname === Endpoints.rendering.status) {\n  //         const statusResponse: RenderingStatusResponse = response\n  //         let steps = 0\n  //         let step = 0\n  //         EncodeTypes.forEach(type => {\n  //           const state = statusResponse[type]\n  //           if (!state) return\n\n  //           steps += state.total\n  //           step += state.completed\n  //         })\n  //         if (steps) eventTarget.emit(EventType.Active, { \n  //           id, step, steps, type: ActivityType.Render \n  //         })\n  //       }\n        \n  //       return delayPromise().then(() => handleApiCallback(id, definition, apiCallback))\n  //     }\n  //     eventTarget.emit(EventType.Active, { id, type: ActivityType.Complete })\n  //   })\n  // }\n\n//   const handleError = (endpoint: string, error: string, id: string) => {\n//     editor.eventTarget.emit(EventType.Active, { \n//       id, type: ActivityType.Error, error: 'import.render', value: error \n//     })\n//     console.error(endpoint, error)\n//     return Promise.reject(error)\n//   }\n\n//   const saveDefinitionsPromise = (definitions: MediaArray): Promise<void> => {\n//     let promise = Promise.resolve()\n//     const { eventTarget } = editor\n// throw new Error('')\n//     // definitions.forEach(definition => {\n//     //   assertContentDefinition(definition)\n//     //   const { label, type, source } = definition\n\n//     //   const id = idGenerate('activity')\n//     //   eventTarget.emit(EventType.Active, { id, label, type: ActivityType.Render })\n\n//     //   const { rendering } = Endpoints\n//     //   console.log(\"Masher fetch\", source)\n//     //   const responsePromise = fetch(source)\n//     //   const blobPromise = responsePromise.then(response => response.blob())\n//     //   const filePromise = blobPromise.then(blob => new File([blob], label))\n//     //   const resultPromise = filePromise.then(file => {\n//     //     const request: RenderingUploadRequest = { type, name: label, size: file.size }\n//     //     console.debug(\"RenderingUploadRequest\", rendering.upload, request)\n//     //     const responsePromise = endpointPromise(rendering.upload, request)\n//     //     return responsePromise.then((response: RenderingUploadResponse) => {\n//     //       console.debug(\"RenderingUploadResponse\", rendering.upload, response)\n//     //       const { error, fileApiCallback, apiCallback, fileProperty } = response\n//     //       if (error) return handleError(rendering.upload, error, id)\n\n//     //       else if (fileApiCallback && fileApiCallback.init) {\n//     //         if (fileProperty) fileApiCallback.init.body![fileProperty] = file\n//     //         else fileApiCallback.init.body = file\n//     //         return jsonPromise(fileApiCallback).then((response: FileStoreResponse) => {\n//     //           console.debug(\"FileStoreResponse\", response)\n//     //           const { error } = response\n//     //           if (error) return handleError(fileApiCallback.endpoint.pathname!, error, id)\n    \n//     //           assertObject(apiCallback, 'apiCallback')\n//     //           return handleApiCallback(id, definition, apiCallback)\n//     //         })\n//     //       } \n//     //       assertObject(apiCallback, 'apiCallback')\n//     //       return handleApiCallback(id, definition, apiCallback)\n//     //     })\n//     //   })\n//     //   promise = promise.then(() => resultPromise)\n//     // })\n//     return promise\n//   }\n\n", "import { ClientOptions } from \"./Client\"\nimport { ClientClass } from \"./ClientClass\"\n\nexport const clientInstance = (args: ClientOptions = {}) => (\n  new ClientClass(args)\n)", "import { isPopulatedString, isString, ValueRecord, Value, isNumber } from \"@moviemasher/moviemasher.js\"\n\nexport enum Config {\n  SUPABASE_PROJECT_URL = 'MOVIEMASHER_SUPABASE_PROJECT_URL',\n  SUPABASE_ANON_KEY = 'MOVIEMASHER_SUPABASE_ANON_KEY',\n  SUPABASE_BUCKET = 'MOVIEMASHER_SUPABASE_BUCKET',\n  SUPABASE_EXPIRES = 'MOVIEMASHER_SUPABASE_EXPIRES',\n  SUPABASE_TABLE = 'MOVIEMASHER_SUPABASE_TABLE',\n}\n\nconst ConfigDefaults: ValueRecord = {\n  [Config.SUPABASE_PROJECT_URL]: '',\n  [Config.SUPABASE_BUCKET]: 'media',\n  [Config.SUPABASE_TABLE]: 'media',\n  [Config.SUPABASE_ANON_KEY]: '',\n  [Config.SUPABASE_EXPIRES]: 60,\n}\n\nexport const config = (key: Config, value?: Value): Value => {\n  if (isString(value) || isNumber(value)) ConfigDefaults[key] = value\n  return ConfigDefaults[key] || ''\n}", "import { \n  Request, LoadType, ProtocolPromise, Plugins, \n  assertTrue, isPopulatedString, \n  endpointAbsolute, \n  CssContentType, RequestInit, urlFromCss, endpointUrl, ImageType, AudioType, VideoType, FontType, HttpProtocol, HttpsProtocol, errorThrow, FontDataOrError, ProtocolType, assertEndpoint, RecordType, RecordsType, AudioDataOrError\n} from \"@moviemasher/moviemasher.js\"\nimport { audioBufferPromise } from \"../Utility/Audio\"\nimport { jsonPromise } from \"../Utility/Json\"\nimport { imageDataPromise } from \"../Utility/Image\"\nimport { videoDataPromise } from \"../Utility/Video\"\n\nconst arrayBufferPromise = (url: string, init?: RequestInit): Promise<ArrayBuffer> => (\n   fetch(url, init).then(response => response.arrayBuffer())\n)\n\nconst fontFamily = (url: string): string => url.replaceAll(/[^a-z0-9]/gi, '_')\n\nconst fontPromise =  (request: Request): Promise<FontDataOrError> => {\n  const { endpoint, init } = request\n  assertEndpoint(endpoint)\n\n  const url = endpointUrl(endpoint)\n  \n  const bufferPromise = fetch(url, init).then(response => {\n    const type = response.headers.get('content-type') || ''\n    // console.log(\"fontPromise.fetch\", type)\n    if (!isPopulatedString(type) || type.startsWith(FontType)) {\n      return response.arrayBuffer()\n    }\n    assertTrue(type.startsWith(CssContentType)) \n    \n    return response.text().then(string => {\n      // TODO: use resolverPromise instead\n      // return resolverPromise(string, type, FontType)\n      const cssUrl = urlFromCss(string)\n      // console.log(\"fontPromise.fetch CSS\", cssUrl)\n      return arrayBufferPromise(cssUrl)\n    })\n  })\n    \n  const family = fontFamily(url)\n  // console.log(\"fontPromise\", url)\n  const facePromise = bufferPromise.then(buffer => {\n    // console.log(\"fontPromise.bufferPromise\", url)\n    const face = new FontFace(family, buffer)\n    return face.load()\n  })\n  return facePromise.then(face => {\n    // console.log(\"fontPromise.facePromise\", url)\n    const { fonts } = globalThis.document\n    fonts.add(face)\n    return fonts.ready.then(() => {\n      \n      // console.log(\"fontPromise.ready\", url)\n      // this.updateLoaderFile(file, info)\n      return { data: face }\n    })\n  })\n}\n\nconst audioPromise =  (request: Request): Promise<AudioDataOrError> => {\n  const { endpoint, init } = request\n  assertEndpoint(endpoint)\n\n  const url = endpointUrl(endpoint)\n  // console.log(this.constructor.name, \"audioPromise\", isBlob ? 'BLOB' : url)\n  return arrayBufferPromise(url, init).then(audioBufferPromise)\n}\n\nconst promise: ProtocolPromise = ((request: Request, type?: LoadType) => {\n  const { endpoint, init } = request\n  assertEndpoint(endpoint)\n\n  const absolute = endpointAbsolute(endpoint)\n  const absoluteRequest = { init, endpoint: absolute }\n  // console.log('http promise', endpoint, absolute)\n  switch (type) {\n    case ImageType: return imageDataPromise(absoluteRequest)\n    case AudioType: return audioPromise(absoluteRequest)\n    case VideoType: return videoDataPromise(absoluteRequest)\n    case FontType: return fontPromise(absoluteRequest)\n    case RecordType: return jsonPromise(absoluteRequest) \n    case RecordsType: return jsonPromise(absoluteRequest)\n  }\n  errorThrow(type, 'LoadType', 'type')\n}) \n\nPlugins[ProtocolType][HttpProtocol] = { promise, type: HttpProtocol }\nPlugins[ProtocolType][HttpsProtocol] = { promise, type: HttpsProtocol }\n", "import { \n  assertEndpoint,\n  assertPopulatedString, AudibleContextInstance, AudioDataOrError, \n  endpointUrl, errorCaught, Request\n} from \"@moviemasher/moviemasher.js\"\n\nconst blobAudioPromise = (url: string): Promise<ArrayBuffer> => {\n  // console.log(this.constructor.name, \"blobAudioPromise\", url)\n\n  return fetch(url).then(response => response.blob()).then(blob => {\n    return new Promise<ArrayBuffer>((resolve, reject) => {\n      const reader = new FileReader()\n      reader.onload = () => { resolve(reader.result as ArrayBuffer) }\n      reader.onerror = reject\n      reader.readAsArrayBuffer(blob)\n    }) \n  })\n}\n\nexport const audioDataPromise = (request: Request): Promise<AudioDataOrError> => {\n  const { endpoint } = request\n  assertEndpoint(endpoint)\n\n  const url = endpointUrl(endpoint)\n  assertPopulatedString(url, 'url')\n  // console.log(this.constructor.name, \"audioPromise\", isBlob ? 'BLOB' : url)\n  const promise = blobAudioPromise(url) \n  return promise.then(audioBufferPromise)\n}\n\nexport const audioBufferPromise = (audio: ArrayBuffer): Promise<AudioDataOrError> => {\n  return AudibleContextInstance.decode(audio).then(data => ({ data }))\n    .catch(error => errorCaught(error))\n}\n\n", "import { Request, isUndefined, urlForEndpoint, assertEndpoint } from \"@moviemasher/moviemasher.js\"\n\nexport interface ResponseObject {\n  json(): Promise<any>\n\n}\nexport const jsonPromise = (request: Request): Promise<any> => {\n  return fetchPromise(request).then(response => response.json())\n}\n\nexport const fetchPromise = (request: Request): Promise<ResponseObject> => {\n  const { endpoint, init = {} } = request\n  assertEndpoint(endpoint)\n  // console.log('jsonPromise', endpoint, init)\n\n  const typeKey = 'Content-Type'\n  const jsonType = 'application/json'\n\n  const formType = 'multipart/form-data'\n\n  init.method ||= 'POST'\n  init.headers ||= {}\n  init.headers[typeKey] ||= jsonType\n  switch (init.headers[typeKey]) {\n    case jsonType: {\n      init.body = JSON.stringify(init.body)\n      break\n    }\n    case formType: {\n      const formData = new FormData()\n      Object.entries(init.body).forEach(([key, value]) => {\n        if (isUndefined(value)) return\n\n        formData.set(key, value instanceof Blob ? value : String(value))\n      })\n\n      init.body = formData\n      delete init.headers[typeKey]\n      break\n    }\n  }\n\n  const url: string = urlForEndpoint(endpoint)\n  return fetch(url, init)\n}\n", "import { \n  endpointUrl, Request, ImageData, ImageDataOrError, ErrorName, error, \n  assertEndpoint \n} from \"@moviemasher/moviemasher.js\"\n\nexport const imageDataPromise = (request: Request): Promise<ImageDataOrError> => {\n  const { endpoint } = request\n  assertEndpoint(endpoint)\n\n  const url = endpointUrl(endpoint)\n  const data = new Image()\n  data.src = url\n  return new Promise<ImageDataOrError>(resolve => {\n    data.onerror = () => {\n      resolve(error(ErrorName.Url))\n    }\n    data.onload = () => { \n      const imageData: ImageData = { data }\n      resolve(imageData) \n    }\n  })\n}\n", "import { \n  endpointUrl, ErrorName, Request, errorThrow, VideoDataOrError, errorCaught, assertEndpoint,\n} from \"@moviemasher/moviemasher.js\"\n\n\nconst videoFromUrl = (url: string): HTMLVideoElement => {\n  const { document } = globalThis\n  if (!document) errorThrow(ErrorName.Environment) \n\n  const video = document.createElement('video')\n  // video.crossOrigin = 'anonymous'\n  video.src = url\n  return video\n}\n\nexport const videoDataPromise = (request: Request): Promise<VideoDataOrError> => {\n  const { endpoint } = request\n  assertEndpoint(endpoint)\n\n  const url = endpointUrl(endpoint)\n  \n  return new Promise<VideoDataOrError>((resolve) => {\n    const clientVideo = videoFromUrl(url)\n    clientVideo.oncanplay = () => {\n      clientVideo.oncanplay = null\n      clientVideo.onerror = null\n\n      const { videoWidth, clientWidth, videoHeight, clientHeight } = clientVideo\n      const width = videoWidth || clientWidth\n      const height = videoHeight || clientHeight\n      clientVideo.width = width\n      clientVideo.height = height\n\n      // console.log(this.constructor.name, \"videoPromise.oncanplay\", width, height)\n      resolve({ data: clientVideo })\n    }\n    clientVideo.onerror = error => { resolve(errorCaught(error)) }\n    clientVideo.autoplay = false\n    // video.requestVideoFrameCallback(() => {})\n    clientVideo.load()\n  })\n}\n", "import { \n  ProtocolPromise, Plugins, Request, AudioType, ImageType, VideoType, \n  BlobProtocol, JsonType, PathData, ProtocolType\n} from \"@moviemasher/moviemasher.js\"\nimport { audioDataPromise } from \"../Utility/Audio\"\nimport { imageDataPromise } from \"../Utility/Image\"\nimport { jsonPromise } from \"../Utility/Json\"\nimport {  videoDataPromise } from \"../Utility/Video\"\n\n\n\nconst promise: ProtocolPromise = ((request: Request, type?: string) => {\n  // console.log('blob promise', url, absolute, endpoint)\n  switch (type) {\n    case AudioType: return audioDataPromise(request)\n    case ImageType: return imageDataPromise(request)\n    case VideoType: return videoDataPromise(request)\n    case JsonType: return jsonPromise(request)\n    // case FontType: return requestFontPromise(request)\n    // case FontType: return errorThrow(type, 'LoadType', 'type')//fontPromise(url)\n    default: {\n      const result: PathData = { path: '' }\n      return Promise.resolve(result)\n    }\n  }\n}) \n\n\n\nPlugins[ProtocolType][BlobProtocol] = { promise, type: BlobProtocol }\n\n", "import {\n  UnknownRecord, \n  Clip, Point, isString, Rect, isObject, isMediaType, \n  MediaType, assertMediaType, StringsRecord, NumberRecord, \n  JsonRecord, isRawType, isAboveZero, isPopulatedString, isArray, \n  DroppingPosition, isUndefined, ClassDropping, ClassDroppingAfter, \n  ClassDroppingBefore, isPopulatedObject, errorThrow, MediaObject, \n  MashAndMediaObject, MediaTypes, mediaTypeFromMime, Strings\n} from \"@moviemasher/moviemasher.js\"\n\nexport const DragSuffix = '/x-moviemasher'\n\nexport type FileInfo = File | UnknownRecord\nexport type FileInfos = FileInfo[]\n\nexport interface DragOffsetObject {\n  offset: number\n}\nexport const isDragOffsetObject = (value: any): value is DragOffsetObject => {\n  return isObject(value) && \"offset\" in value\n}\nexport function assertDragOffsetObject(value: any): asserts value is DragOffsetObject {\n  if (!isDragOffsetObject(value)) errorThrow(value, 'DragOffsetObject')\n}\n\nexport interface DragDefinitionObject extends DragOffsetObject {\n  mediaObject: UnknownRecord\n}\nexport const isDragDefinitionObject = (value: any): value is DragDefinitionObject => {\n  return isDragOffsetObject(value) && \"mediaObject\" in value && isObject(value.mediaObject)\n}\nexport function assertDragDefinitionObject(value: any): asserts value is DragDefinitionObject {\n  if (!isDragDefinitionObject(value)) errorThrow(value, 'DragDefinitionObject')\n}\n\nexport interface DragLayerObject extends UnknownRecord {\n  offset: number\n  mashAndMedia?: MashAndMediaObject\n}\n\n\nexport type Draggable = MediaObject | MashAndMediaObject | Clip | FileList\n\n\nexport const TransferTypeFiles = \"Files\"\nexport type TransferType = string \nexport const isTransferType = (value: any): value is TransferType => {\n  return isString(value) && value.endsWith(DragSuffix)\n}\n// \nexport const dropType = (dataTransfer?: DataTransfer | null): TransferType | undefined => {\n  if (!dataTransfer) return\n  \n  return dataTransfer.types.find(isTransferType)\n}\n\nexport const dragMediaType = (transferType: TransferType): MediaType => {\n  const [type] = transferType.split('/')\n  assertMediaType(type)\n  return type\n}\n\nexport const dragType = (dataTransfer?: DataTransfer | null): MediaType | undefined => {\n  const prefix = dropType(dataTransfer)\n  if (!prefix) return\n\n  const [type] = prefix.split('/')\n  if (isMediaType(type)) return type\n}\n\nexport const dragTypes = (dataTransfer: DataTransfer): Strings => {\n  const { types } = dataTransfer\n  return types.filter(type => (\n    type === TransferTypeFiles || isTransferType(type)\n  ))\n}\n\nexport const dragData = (dataTransfer: DataTransfer, type?: TransferType) => {\n  const transferType = type ? `${type}${DragSuffix}` : dragTypes(dataTransfer).find(isTransferType)\n  if (!transferType) return {}\n\n  const json = dataTransfer.getData(transferType)\n  // console.log(\"dragData\", json, type, transferType)\n  const data = json ? JSON.parse(json) : {}\n  return data\n}\n\nexport const DragElementRect = (current: Element): Rect => current.getBoundingClientRect()\n\nexport const DragElementPoint = (event: DragEvent, current: Element | Rect,): Point => {\n  const rect = (current instanceof Element) ? DragElementRect(current) : current\n  const { x, y } = rect\n  const { clientY, clientX } = event\n  return { x: clientX - x, y: clientY - y }\n}\n\nexport const dropFilesFromList = (files: FileList, serverOptions: JsonRecord = {}): FileInfos => {\n  const infos: FileInfos = []\n  const { length } = files\n  if (!length) return infos\n\n  const exists = isPopulatedObject(serverOptions)\n  const { extensions = {}, uploadLimits = {} } = serverOptions\n  const extensionsByType = extensions as StringsRecord\n  const limitsByType = uploadLimits as NumberRecord\n\n  for (let i = 0; i < length; i++) {\n    const file = files.item(i)\n    if (!file) continue\n\n    const { name, size, type } = file\n    const coreType = mediaTypeFromMime(type) \n    if (!isRawType(coreType)) {\n      infos.push({ label: name, value: coreType, error: 'import.type' })\n      continue\n    }\n    \n    const max = limitsByType[coreType]\n    if (exists && !(isAboveZero(max) && max * 1024 * 1024 > size)) {\n      infos.push({ label: name, value: `${max}MB`, error: 'import.bytes' })\n      continue\n    }\n\n    const ext = name.toLowerCase().split('.').pop()\n    const extDefined = isPopulatedString(ext)\n    const exts = extensionsByType[coreType]\n    if (exists || !extDefined) {\n      if (!(extDefined && isArray(exts) && exts.includes(ext))) {\n        infos.push({ label: name, value: ext, error: 'import.extension' })\n        continue\n      } \n    }\n    infos.push(file)\n  }\n  console.log('dropFilesFromList infos', infos)\n  return infos\n}\n\n\nexport const droppingPositionClass = (droppingPosition?: DroppingPosition | number): string => {\n  if (isUndefined(droppingPosition)) return ''\n\n  switch (droppingPosition) {\n    case DroppingPosition.After: return ClassDroppingAfter\n    case DroppingPosition.Before: return ClassDroppingBefore\n    case DroppingPosition.None: return ''\n  }\n  return ClassDropping\n}\n", "import { roundWithMethod } from \"@moviemasher/moviemasher.js\"\n\nexport const pixelPerFrame = (frames: number, width: number, zoom = 1): number => {\n  if (!(frames && width)) return 0\n\n  const widthFrames = width / frames\n\n  const min = Math.min(1, widthFrames)\n  const max = Math.max(1, widthFrames)\n  if (zoom === 1) return max\n  if (!zoom) return min\n\n  return min + ((max - min) * zoom)\n}\n\nexport const pixelFromFrame = (frame: number, perFrame : number, rounding = 'ceil'): number => {\n  if (!(frame && perFrame)) return 0\n\n  const pixels = frame * perFrame\n  return roundWithMethod(pixels, rounding)\n}\n", "import { Identified } from \"@moviemasher/moviemasher.js\"\n\n\n\nexport enum ActivityType {\n  Analyze = 'analyze',\n  Complete = 'complete',\n  Error = \"error\",\n  Load = 'load',\n  Render = 'render',\n}\n\nexport interface ActivityInfo extends Identified {\n  type: ActivityType\n  label?: string\n  steps?: number\n  step?: number\n  error?: string\n  value?: string\n}\n"],
  "mappings": "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",
  "names": ["VideoType", "ProbeType", "operation", "id", "error", "promise", "ProbeType", "VideoType", "Config", "isPopulatedString", "endpointUrl", "ImageType", "AudioType", "VideoType", "errorThrow", "assertEndpoint", "assertPopulatedString", "promise", "error", "assertEndpoint", "endpointUrl", "ErrorName", "error", "assertEndpoint", "endpointUrl", "ErrorName", "errorCaught", "assertEndpoint", "error", "assertEndpoint", "endpointUrl", "isPopulatedString", "ImageType", "AudioType", "VideoType", "errorThrow", "Plugins", "AudioType", "ImageType", "VideoType", "ProtocolType", "promise", "AudioType", "ImageType", "VideoType", "Plugins", "ProtocolType", "isString", "isPopulatedString", "isArray", "isUndefined", "errorThrow", "ActivityType"]
}
